/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod}iâEÿ;∆tPˇu‡ˇ Íiˇuÿˇ5Ä¸Èiˇ ÍiâEÿÉ} t2hb ˇ ãu‰VSWWˇ5Ä¸Èiˇ‘!Íiˇuˇuˇ5Ä¸ÈiãMˇT0ÍiˇUÎ%ˇuˇuWWˇ5Ä¸ÈiÉ}$ tˇÑ ÍiÎˇà!Íiãu‰âE‹Ö¿th  ˙ VSWWˇ5Ä¸Èiˇ‘!ÍiãE‹Ö¿uÉ}ˇuqWãu‡Vˇ  ÍiâEÃhˇˇˇ Vˇ ÍiâE»ãM–Ö…uã|¸ÈiQVˇ Íiãh  ∏ WWˇ5Ä¸Èiˇu‰Sˇuˇuã}‡WˇP ÍiVWˇ ÍiˇuÃWˇ  Íiˇu»Wˇ Íiˇuÿˇ5Ä¸Èiˇ ÍiÉ}‘ˇtˇu‘Sˇ5Ä¸Èiˇ¸ Íih»ˇÈiˇ8'ÍiãE‹Î3¿ãMdâ    Y_^[…¬  ã3¿Ö“tâãVRãpãŒˇT0Íiˇ÷^√ã3¿Ö“tâãVRãpãŒˇT0Íiˇ÷^√dã   ãÅ‹  Ö¿y»3“98˝ÈitVã±`  ã∆Åd  t9V~B^ã¬√3¿@Ö…t;»t3¿√3¿@Ö…t;»tÉ˘t
jWˇ¨%Íi3¿√ãˇUãÏÉ‰¯ÅÏD  °8ıÈi3ƒâÑ$@  ãES∑]VWRj	âL$$çå$@  ZâD$ËG®˘ˇçD$ ã”PçD$PçD$PçD$$PçD$Pçå$L  Ë˜   ãL$ã¯ÖˇÖñ   9Eu˜¡   Ñ¡   É·˝çÑ$8  Éd$  ∫®ú‡iâL$fã0f;2ufÖˆtfãpf;ruÉ¿É¬fÖˆuﬁ3¿Î¿É»Ö¿t>h®ú‡ij	Zçå$<  Ë¶ß˘ˇj çD$ã”PçD$PçD$$PçD$Pçå$L  ËY   ãL$ã¯ãT$çÑ$8  Qˇt$ãœPˇt$(çD$0Pˇt$(ËT.ˇˇçT$ ãœãËnËˇˇjYË]É¸ˇã∆ãå$L  _^[3ÃË¯%˚ˇãÂ]¬ ãˇUãÏÅÏ(  °8ıÈi3≈âE¯Sã]Vãu∑¬âÖË˝ˇˇWã˘ãMâç‹˝ˇˇãMâç‡˝ˇˇãMâç‰˝ˇˇÖˆth  j VËáe˚ˇãÖË˝ˇˇÉƒãç‰˝ˇˇQSPã◊ççÏ˝ˇˇËÒˇˇÖ¿tVˇµ‡˝ˇˇã◊ã»ˇµ‹˝ˇˇSË   ãM¯_^3Õ[ËV%˚ˇ…¬ ãˇUãÏÅÏ¥  °8ıÈi3≈âE¸ãESVãuãŸâÖ®˚ˇˇãEWâÖp˚ˇˇ3ˇãEh  âÖl˚ˇˇçÖË˚ˇˇWPâïx˚ˇˇâù§˚ˇˇË‰d˚ˇÉƒWWSˇ<#Íiã¯âΩî˚ˇˇÈ  Å˚Ïõ‡iÑá  jWˇ #ÍijWâÖò˚ˇˇˇ #ÍiâÖú˚ˇˇÖˆtKãÖ®˚ˇˇ˜     u*ˇÙ!Íidã0   9Å‘  tˇ‰&Íidã0   9Å‘  ujWˇ #ÍiãÿâÖ∞˚ˇˇÎ3€âù∞˚ˇˇÖ€Ñ¨  j VãÀˇT0Íiˇ”Ö¿Ñó  É>Éã  É•à˚ˇˇ É> vsãΩà˚ˇˇçFçûê  âÖ¨˚ˇˇj ççÄ˚ˇˇ3“QççÑ˚ˇˇQˇµ®˚ˇˇã»Ë®˛ˇˇôâC¯¬âS¸tãÖÑ˚ˇˇâãÖÄ˚ˇˇâCãÖ¨˚ˇˇGÉ¿HÉ√âÖ¨˚ˇˇ;>rÆãΩî˚ˇˇãù∞˚ˇˇh∞®‡içÖå˚ˇˇPˇ\'ÍiçÖå˚ˇˇ«ÖT˚ˇˇ   âÖ\˚ˇˇ3…çÖT˚ˇˇâçX˚ˇˇPh  çÖ†˚ˇˇ«Ö`˚ˇˇ@   Pâçd˚ˇˇâçh˚ˇˇˇP'ÍiÖ¿à®   h<®‡içÖå˚ˇˇPˇ\'ÍiçÖ|˚ˇˇPjçÖ»˚ˇˇPjçÖå˚ˇˇPˇµ†˚ˇˇˇD'ÍiÖ¿xãÖ‘˚ˇˇâÜ  Éæ   tGh®‡içÖå˚ˇˇPˇ\'ÍiçÖ|˚ˇˇPjçÖ¥˚ˇˇPjçÖå˚ˇˇPˇµ†˚ˇˇˇD'ÍiÖ¿xãÖ¿˚ˇˇâÜ  ˇµ†˚ˇˇˇL'ÍiÎÉ& ÉΩú˚ˇˇ uÉΩò˚ˇˇ ÑH  ˇµx˚ˇˇÉ•∞˚ˇˇ çÖL˚ˇˇÉ•¨˚ˇˇ Pˇ\'ÍiçÖt˚ˇˇPjçÖL˚ˇˇPˇX'ÍiãÖ®˚ˇˇ˜     uFˇÙ!Íidã0   9Å‘  t1ˇ‰&Íidã0   9Å‘  tçÖ‹˚ˇˇj PËWÏˇˇÖ¿t
çÖ‹˚ˇˇ3…Îãç¨˚ˇˇãÖ∞˚ˇˇãïú˚ˇˇÖ“t#j QPçÖ˝ˇˇã Pˇµt˚ˇˇˇT0Íiˇïú˚ˇˇÖ¿u#ãÖò˚ˇˇÖ¿tzçç˝ˇˇQã»ˇT0Íiˇïò˚ˇˇÖ¿taˇÙ!Íidã0   9Å‘  t ˇ‰&Íidã0   9Å‘  tÖ€uÉé  j j çÖ˝ˇˇPˇ<#ÍiãÿÖ€tçÖ˝ˇˇWâÖ§˚ˇˇˇH#Íiã˚jWˇ #ÍiãÿÖ€ÖÇ   3…Öˆt1ãŸ9v)çæà  É˚sãGtˇ7ˇL'Íi3…ââOCÉ«;r›âãÖ®˚ˇˇ9}.∏Ïõ‡i9Ö§˚ˇˇt!QQPãÿâÖ§˚ˇˇˇ<#Íiã¯âÖî˚ˇˇÖˇÖÎ˚ˇˇ3¿ãM¸_^3Õ[ËΩ ˚ˇ…¬ ãÀˇT0Íiˇ”ãçp˚ˇˇ+«âÖˆtj ZRˇµ§˚ˇˇçéD  ËŒ.˘ˇ3¿fâÜÇ  ãùl˚ˇˇjWÉ# ˇ #ÍiãÖˆtãŒˇT0Íiˇ÷+«âh  çÖË˚ˇˇPWˇ,#ÍiWˇH#Íi3¿PPjPjh   ÄçÖË˚ˇˇPˇê"ÍiÈYˇˇˇÃÃÃÃÃÃãˇUãÏãM˜¡ ¢ˇˇthÏ  ˇ¨%Íi3¿ÎË°‡ˇˇPˇ`(Íi]¬ ÃãˇUãÏÉ‰¯ÉÏ0ãEãUVWj	Yçpã ç|$Û•âD$çL$3¿«D$0   jPPâD$@Ë˚2˘ˇ_^ãÂ]¬ ãˇVãÒË≤˜ˇˇã∆^√ãˇVãÒË¡˜ˇˇã∆^√ãˇVã5tÍiQãŒˇT0Íiˇ÷^√ãˇUãÏVãuÖ…tVË   Î∏  ¿Ö¿yÖˆtÉ& ^]¬ ãˇUãÏQVæ  Wã÷3ˇf99tÉ¡ÉÍuÛãMã¬˜ÿ¿%Ûˇˇ?  ¿Ö…tÖ“t+Úâ1Îâ9_^…¬ ãˇUãÏQVçE¸ãÒPËô   Ö¿x*ãE—Ë=˛ˇˇv∏W ÄÎPãE¸∫ö   ˇu+–QçFË   ^…¬ h˛ˇˇh–©‡iQ∫ö   Ë   ¬ ãˇUãÏÖ“t)ãEVãu+¡WÖˆt∑<fÖˇtfâ9É¡NÉÍuÁ_^Ö“uÉÈ˜⁄“Å‚Üˇ¯3¿fâçÇz Ä]¬ ãˇUãÏQVæö   Wã÷3ˇf99tÉ¡ÉÍuÛãMã¬˜ÿ¿%©ˇ¯W ÄÖ…tÖ“t+Úâ1Îâ9_^…¬ ãˇUãÏSVWˇuçrˇã˘ˇu3€VWˇ'ÍiÉƒÖ¿x
;∆wt	ãÎªz Ä3¿fâwãMÖ…tâ1_^ã√[]¬ ãˇUãÏˇuËaˇˇˇ]¬ 3¿¬ ãˇVã5lÍiWã˘ãŒˇT0Íiãœˇ÷_^√ãˇUãÏQÉe¸ çE¸VPˇuãÚˇÿ%ÍiÉ=¥ıÈi u3¿Î&É}¸ uVj ˇ\-Íi3¿@Îh   Ëbf˙ˇ¡Ë˜–É‡^…¬ ãˇUãÏÉÏSV3ˆâUÙVã¡VPâE¸ˇ| Íiãÿâ]Ö€t~W¡‡PVˇ¿"Íiã¯ÖˇtkWSˇu¸ˇ| ÍiÖ¿tUãGÖ¿~)ãç_ ãEˇ∞   ˇ∞   ˇuÙSˇ‡(ÍiÉ√ÉÓuﬂã]WSVˇx ÍiãÿÖ€tjVSˇu¸ˇ® ÍiSãˇH ÍiWˇº"Íi_ã∆^[…¬ ãˇQ2“Ëä˙˙ˇY√ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏ]ˇ%(ÍiÃÃÃÃãˇUãÏjJˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQQ°¸Èiã¸ÈiSVW∑¯;¡w∑˘ãu¡Ë@â}¸Pˇ5¸ÈiVËı[˚ˇ°$¸ÈiçNã ¸ÈiÉƒâE¯3€°¸Èi¡Ë»ã¡+∆;Œ…˜—#»vã}¯äÉ¬É◊ FC;Ÿrã}¸fã«_^[…¬ ÃÃÃÃÃÃÃÃÃÃÃÃjË5˚ˇ√ÃÃÃÃÃÃÃÃãˇUãÏj.ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjiˇuˇh*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãU3¿ãMh‡©ÁiPPPËûŸ˛ˇ∑¿]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ}Vu\É}uVãMËVè˙ˇããŒ u3¿ÎSˆFu<∑F*%ˇ?ˇˇ=¢  u,RVËuü˙ˇÖ¿t!ãÜ(  ããHã¬¡t˜BP @  uãB@ã Îj ˇuˇuˇuˇ0Íi^]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãMË”é˙ˇã» u3¿Îˆ@ ujˇuˇH+Íi3¿@]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj j ˇuˇuˇuˇuˇuˇuË   ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏSV3€3ˆ9]$tjWˇ¨%Íi3¿È    ˇuçE¯Pˇ@&ÍijçE¯PçEPˇD&ÍiÖ¿y
Pˇ‡&ÍiPÎ»Wã}Öˇt=WçE¯Pç]Ëˇ@&ÍijçE¯Pã√PˇD&ÍiÖ¿yPˇ‡&ÍiPˇ¨%ÍiçEPˇ‡%Íi3¿ÎY9utˇuˇê Íiãˇu ã”çMˇuˇuˇuVË!‹ˇˇãÿçEPˇ‡%ÍiÖˇt
çEËPˇ‡%ÍiÖˆtd°0   Vj ˇpˇd'Íiã√_^[…¬  ÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏçEVˇuPˇ\'ÍiãuçE¯VPˇ\'Íiˇu ˜ﬁçU¯ˇuˆçMˇu#÷ˇuˇuËñ€ˇˇ^…¬  ÃÃÃÃÃÃÃãˇUãÏj j ˇuˇuˇuˇuˇuˇuËêˇˇˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ‰¯ÉÏçD$VˇuPˇ‰%ÍiÑ¿u3¿Î!ˇuãUçL$ˇuËë€ˇˇãçD$Pˇ‡%Íiã∆^ãÂ]¬ ÃÃÃÃÃÃãˇUãÏQQˇuçE¯Pˇ\'ÍiˇuãUçM¯ˇuËP€ˇˇ…¬ ÃÃÃÃÃÃÃãˇUãÏjˇu(ˇu$ˇu ˇuˇuˇuˇuˇuˇuˇ∞)Íi]¬$ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃjËu˚ˇ√ÃÃÃÃÃÃÃÃãˇUãÏjKˇuˇT*Íi]¬ Ëå˘ˇPˇ‡&ÍiÖ¿~∑¿  Ä√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjhˇuˇuˇ¨*Íi]¬ ÃÃÃÃÃÃÃÃÃj)Ë˚ˇ√ÃÃÃÃÃÃÃÃãˇUãÏhã   ˇuˇuËÛ˚ˇ]¬ ÃÃÃÃÃÃÃãˇUãÏj ˇ¨%Íij1ˇuˇT*Íi]¬ ÃÃÃÃãˇUãÏãUãMjˇuˇuË·ˇˇ]¬ ÃÃÃÃãˇUãÏãUãMj ˇuˇuËÏ‡ˇˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏãEâEãE˜ÿ«EÏ   «E¯   ¿Ée¸ É‡âEÙçEÏPˇ$/Íi…¬ ÃÃÃÃÃãˇUãÏjQˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏ3¿9Eï¿Pˇú+Íi]¬ ãˇUãÏÉÏd°8ıÈi3≈âE¸SVWçE»ã˘Ph   ˇT'ÍiÖ¿àh  h@ù‡içEÃPˇ\'ÍiãE»3€âE∞çEÃj^âE¥çE¨Ph  çE‘âu¨P«E∏@   â]ºâ]¿ˇP'ÍiÖ¿çEÃxthpù‡iPˇ\'ÍiçE®Pj$çEÿPjçEÃPˇu‘ˇD'Íiçà˚ˇˇ˜Ÿ…#»ãœ|çE‰PÎh®ú‡ij	ZËÏñ˘ˇˇu‘ˇL'Íiˇu»ˇL'Íi°(¸Èiˆ Ñ≈  ãœËU÷ˇˇÈπ  h ù‡iPˇ\'ÍiãE»âE∞çEÃâE¥çE¨Ph?  çE‘âu¨P«E∏@   â]ºâ]¿ˇP'Íiˇu»ãˇL'ÍiÖˆà\  æù‡içEÃVPˇ\'ÍiçE®Pj$çEÿPjçEÃPˇu‘ˇD'Íiçà˚ˇˇ˜Ÿ…#»ãœå  çE‰Pj	ZË)ñ˘ˇ°(¸Èiˆ t4jSWˇ‘%Íi%ˇ  ÉƒfÉ¯uhtù‡iÎfÉ¯uhàù‡ij	ZãœËÎï˘ˇh z‡içEÃPˇ\'ÍiãE‘âE∞çEÃâE¥çE†PSSSçE¨«E¨   Ph  çEƒ«E∏@   Pâ]ºâ]¿ˇ–%ÍiÖ¿yˇu‘ˇL'ÍiÈâ   hpù‡içEÃPˇ\'ÍiãœçQfãÉ¡f;√uı+ —˘çM   PWjSçEÃPˇuƒˇÃ%ÍiÖ¿yˇu‘ˇL'ÍiˇuƒÎßVçEÃPˇ\'ÍiçEÃPˇu‘ˇ»%ÍiÎÿh®ú‡ij	ZËï˘ˇÈxˇˇˇh®ú‡ij	ZãœËï˘ˇãM¸_^3Õ[Ë√˚ˇ…√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãM2“ËúÒ˙ˇÖ¿uÉ»ˇÎÉ‡]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿u]¬ ]ˇ%Ñ(ÍiÃÃÃÃÃÃÃÃÃã(¸Èi∑Åt  ∑âp  ¡‡¡√ÃÃÃÃÃÃãˇUãÏ]ˇ%x(ÍiÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãM2“ËÏ˙ˇÖ¿t¡Ë%ˇ  ]¬ ãˇUãÏÉ} Vt∑qÎ3ˆfãAf∆f#¬^]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃjË%˚ˇ√ÃÃÃÃÃÃÃÃˇ%d#ÍiÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏˇÙ!Íidã0   9Å‘  taˇ‰&Íidã0   9Å‘  tLçEÙj PËé‹ˇˇÖ¿tãEÉË t0ÉËtÉËt-¸ˇˇtÉËt	3¿Î&ãE¸Î!É}Ùu∑E¯ÎãE¯ÎãEÙÎj3ˇuˇT*Íi…¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjVˇuˇÄ)Íi]¬ Ëá9˙ˇÖ¿u√ã@<√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj4ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃdã   ãÅ‹  Ö¿y»ãAxA|Vujˇƒ*ÍiÖ¿t/d°   ãà‹  Ö…y¡ãà   ãq(ãQ,ãŒ tãÄ(  ã^√3¿^√ÃÃÃÃÃãˇUãÏj-ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃdã   ãÅ‹  Ö¿y»ãAxA|Vujˇƒ*ÍiÖ¿t/d°   ãà‹  Ö…y¡ãà   ãq ãQ$ãŒ tãÄ(  ã^√3¿^√ÃÃÃÃÃdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿u√d°   ãà‹  Ö…y¡ãÄ  √ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃjËÂ˚ˇ√ÃÃÃÃÃÃÃÃãˇUãÏˇuãEˇuˇuˇ0ˇuˇ%ÍiÖ¿yPˇ‡&ÍiPˇ¨%Íi3¿Î3¿@]¬ ÃÃÃÃÃÃÃãˇUãÏj5ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjWˇuˇÄ)Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿t%ãMVË€É˙ˇã» tã∞$  ÎjWÉŒˇˇ¨%Íiã∆^]¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjuˇuˇh*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãUãMjˇu(ˇu$ˇu ˇuˇuˇuˇuËL‰ˇˇ]¬$ ÃÃÃÃÃãˇUãÏãUãMj ˇu(ˇu$ˇu ˇuˇuˇuˇuË‰ˇˇ]¬$ ÃÃÃÃÃjˇƒ*Íi√ÃÃÃÃÃÃÃãˇUãÏãMV3ˆËÉ˙ˇã»¬t∂±Î   —ÓÉÊã∆^]¬ ÃÃÃÃÃÃÃdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿u√d°   ãà‹  Ö…y¡ãÄ‡  3…É‡@¡tAã¡√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃjË’˚ˇ√ÃÃÃÃÃÃÃÃãˇUãÏãMËsÇ˙ˇã» ujWˇ¨%Íi3¿Î∂ÄÍ   ¡ËÉ‡]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãM2“Ë¸Î˙ˇ˜ÿ¿˜ÿ]¬ ÃÃÃÃÃÃÃãˇUãÏãMËÇ˙ˇã» ujWˇ¨%Íi3¿ÎˆÄÈ   u	Ä∏Í    }Í3¿@]¬ ÃÃÃÃÃÃÃÃãˇUãÏÅÏ  °8ıÈi3≈âE¸ãEççÙ˝ˇˇVãuW3ˇâç˝ˇˇWh  çç˝ˇˇQjˇPWËﬂ5˘ˇÖ¿tWVWçïÙ˝ˇˇ3…Ë
ÊˇˇãM¸_3Õ^ËL˚ˇ…¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãMÖ…u3¿ÎãUj ˇuj Ë–Âˇˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãU3…j ˇuj Ë©Âˇˇ]¬ ÃÃÃÃÃÃj7j ˇT*Íi√ãˇUãÏÉÏ$°8ıÈi3≈âE¸VˇÙ!Íidã0   9Å‘  tˇ‰&Íidã0   9Å‘  t3ˆFÎj^Vhy‡içEÙjPË&ø˙ˇÉƒçE‡h¯y‡ij	PhTz‡içEÙPh z‡iˇ¥#ÍiÉ¯ˇt#fÉ}‡ tj hí   j çU‡3…Ë˝‰ˇˇFÅ˛Ë  r•ãM¸3Õ^Ë7˚ˇ…√ÃÃÃÃÃÃÃÃj7jˇT*ÍijˇÄ Íi√ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj6ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj9ˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjaˇuˇuˇ¨*Íi]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏQQˇuçE¯Pˇ‰%ÍiÑ¿u3¿Î!ãUçM¯VˇuˇuËh—ˇˇãçE¯Pˇ‡%Íiã∆^…¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQQˇuçE¯Pˇ\'ÍiˇuãUçM¯ˇuË!—ˇˇ…¬ ÃÃÃÃÃÃÃãˇUãÏãMËS˙ˇã» u3¿Îˆ@ tjˇuˇH+Íi3¿@]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQQˇuçE¯Pˇ‰%ÍiÑ¿u3¿ÎãUçM¯VˇuË¸–ˇˇãçE¯Pˇ‡%Íiã∆^…¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQQˇuçE¯Pˇ\'ÍiˇuãUçM¯Ëµ–ˇˇ…¬ ÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ} uÉ} ujOˇuˇT*ÍiÎ
jWˇ¨%Íi3¿]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏhÑ   ˇuˇuË£	˚ˇ]¬ ÃÃÃÃÃÃÃãˇUãÏhÇ   ˇuˇuËÉ	˚ˇ]¬ ÃÃÃÃÃÃÃãˇUãÏjbˇuˇuˇ¨*Íi]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏÉ} uj>ˇuˇT*Íi]¬ ÃÃÃÃÃÃãˇUãÏhÖ   ˇuˇuË#	˚ˇ]¬ ÃÃÃÃÃÃÃãˇUãÏjgˇuˇuˇ¨*Íi]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏjBˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃ¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjˇuj jË]x˘ˇ]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏjDˇuˇT*Íi]¬ ãˇRQˇ‘+Íi√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ3¿@¬ ÃÃÃÃÃÃÃÃÃÃãˇUãÏjwˇuˇuˇ¨)Íi]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏjFˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj\ˇuˇd(Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjSˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏˇuˇuˇå+Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjRˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj]ˇuˇd(Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿uÉ»ˇÎIãMVÖ…tÉ˘tjWÉŒˇˇ¨%ÍiÎ,d°   ãê‹  Ö“y¬ã∞  ;Òt«ÄÙ     âà  ã∆^]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏdã   ãÅ‹  Ö¿y»ãAxA|ujˇƒ*ÍiÖ¿thâ   ˇuˇuËº˚ˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ}u0ˇ‰#Íi;EuÉ}uãEπ¥ıÈiã á3¿@]¬ jWˇ¨%Íi3¿Î]ˇ%@(ÍiÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏ]È•ˇˇˇÃÃÃÃÃãˇUãÏãEˇuˇ0ˇuˇÏ%ÍiÖ¿yPˇ‡&ÍiPˇ¨%Íi3¿Î3¿@]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjHˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQãMçE¸PËÿÊˇˇÖ¿xˇu¸ˇuˇuˇÄ(ÍiÎ
jWˇ¨%Íi3¿…¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjIˇuˇT*Íi]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj j ˇuˇT(Íi]¬ ÃÃÃÃÃÃÃÃÃÃãˇUãÏ]ˇ%T(ÍiÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏjzˇuˇuˇ¨)Íi]¬ ÃÃÃÃÃÃÃÃÃãˇUãÏãU3¿ãMh¿ÆÁiPPPËŒ√˛ˇ∑¿]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏçE¯SVWã}WˇujPˇuˇuˇuË™é˘ˇãÿôã3Ú+ÚtW;=pÍit)jçE¸Ph  ∑«Pˇh#ÍiÖ¿t2ãE¸£tÍiâ=pÍiÎ°tÍiçMÙQj jˇuçM¯VQj Pˇ\$ÍiÖ¿u3¿ÎÖ€y˜ﬁã∆_^[…¬ ÃÃÃÃÃÃÃÃÃãˇUãÏãMËÛx˙ˇ¬ujWˇ¨%Íi3¿Îˇu$ãE É»PˇuˇuˇuˇuˇuËıç˘ˇ]¬  ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏhä   ˇuˇuËÛ˚ˇ]¬ ÃÃÃÃÃÃÃãˇUãÏˇuˇh(ÍiÖ¿t3…AËïa¸ˇ3¿@Î3¿]¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏQQÉM¯ˇçE¯Pj∆E¸ ˇ‹%ÍiÖ¿àá  Ä}¸ Ñ}  ãM«`¸Èi≥Âi«h¸Èi!Ëiã£XÙÈiãA£TÙÈiãA£PÙÈiãA£LÙÈiãA£HÙÈiãA£DÙÈiãA£@ÙÈiãA£xÍiãA £tÍiãA$£pÍiãAH£‹ÍiãAL£ÿÍiãA(£d¸ÈiãA,£\¸ÈiãA4£dÙÈiãA8£`ÙÈiãA0£\ÙÈiãAD£‡ÍiãA@£‰ÍiãAP£‘ÍiãA`£»ÍiãA\£lÍiãAT£–ÍiãAXãM£ÃÍi°<(ÍiâA<°X(ÍiâA@°\(ÍiâAH°¸)ÍiâAP∏˘Èi«   
«A@ÌÁi«A ØËi«A0≤Êi«A†˙Ái«A ÎÁi«A`≈Ëi«A†€Ëi«A ∞∫‚i«A$ ¥Âi«A(∫Âi«A,–»Ëi«A0‡»Ëi«A4 Ëi«A8ê≥Âi«AD ÆÊi«AL …Ëi«ATXû‡iÎ∏"  ¿…¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏçEËSã]j jPj SˇÙ%ÍiÖ¿y-=$  ¿uˆ√tjˇuÉ„¸SÎˆ√t3¿Îjˇ¨%ÍiÉ»ˇÎj ˇuˇu¯ˇ4(Íi[…¬ ãˇUãÏãM3¿f9Å  ï¿]¬ ãˇUãÏQSVWçE¸3ˇPWãÒâ}¸ˇ(∞ÍiÖ¿u9Vªàä·iShxä·iˇu¸Wˇ4∞ÍiÖ¿uVShxä·iˇu¸Wˇ8∞ÍiÖ¿u
ˇu¸Wˇ$∞Íi3€Ö¿î√9}¸t	ˇu¸ˇº"Íi_^ã√[…√ãˇUãÏ3¿VÖ“t*ãuSWã}+ÒÖˇt∑fÖ€tfâÉ¡O@ÉÍuÊ_[Ö“uÉÈH˜⁄“3ˆfâ1Å‚Üˇ¯ãM^Ö…tâçÇz Ä]¬ ãˇUãÏ3¿Ö“t;Uv∏W Ä]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏdã   ÉÏãÅ‹  Ö¿y»SVãuã∆EWj ZuâU¸ÎãâE¸ãEã}ãuâEÙâ}¯âuãÅh  âEÏd°   ãà‹  Ö…y¡ãÄ   É‡¬t3“BˇuçEÏPRh   Ë\Ω˙ˇãœãÿËér˙ˇÖ¿tVË)⁄¸ˇÎÅˇ  uVË©Æ¸ˇ_^ã√[…¬ ãˇUãÏãUÉÏã¬Ej YuâM¸ÎãâE¸ãESâEÙd°   VãuWã}â}¯âuãê‹  Ö“y¬ãÄ   É‡¡t3…AˇuçEPQh   Ë»º˙ˇãœãÿË˙q˙ˇÖ¿tVËïŸ¸ˇÎÅˇ  uVËÆ¸ˇ_^ã√[…¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ‰¯ãUçD$–ãMÉÏ0PˇuˇuËa—˛ˇãMç$j Pjh   É ˇËÑ˝¯ˇãÂ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãUãMj ˇuˇuˇuˇuËÎˇˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãUãMj j ˇuˇuˇuËºˇˇ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏ3¿É}î¿H]¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏ]ˇ%¨(ÍiÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãMVË‚r˙ˇããŒ t'ãF ô9F u9V$uˇuˇuˇv ˇ,#ÍiÎ
j~ˇ¨%Íi3¿^]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ‰¯ãMçD$–ÉÏ4Vãuã÷PˇuˇuË–˛ˇãUçD$ãMÅÊ   j PjVË>¸¯ˇ^ãÂ]¬ ÃÃÃÃÃÃÃÃÃÃãˇUãÏÉ‰¯ãMçD$–ÉÏ4Vãuã÷PˇuˇuËŒœ˛ˇãUçD$ãMÅÊ   j Pj VËÓ˚¯ˇ^ãÂ]¬ ÃÃÃÃÃÃÃÃÃÃjËE˝˙ˇj ˇÙ#ÍiÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏhÉ   ˇuˇuË#˝˙ˇ£dÍi]¬ ãˇQjˇ5Ë˘Èiˇh'Íi√ãˇQj ˇ5Ë˘Èiˇd'Íi√ãQV3ˆ—9qvãçRF;qrÚ^√3¿É˘w=tOÉ˘v2É˘tEÉ˘t$É˘uãJ+»tÉÈtIÉÈt	ÉÈujX√jX√jX√jX√É˘tÎÉ˘
tÉ˘tÌÉ˘ˇuﬂjX√Ézu’ÎÿãˇUãÏÉÏ(j j(çEÿ«E¸   PjjˇˇÙ%ÍiÖ¿xãEÿ…√3¿…√∑¡Ø ˙Èi¯˘Èiô√ÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏVãuW3ˇâ}â}¯â}¸9~t9~uãŒË	ˇˇˇãN(çF$˜Ÿ…#»Qˇv ˇvˇp ÍiWâEËçEËjPâ}Ïˇp&Íi_^…¬ ÃÃÃÃÃãˇUãÏÉÏ\°8ıÈi3≈âE¯jPçE§j PË<˚ˇÉƒ«E§  ¿çE§«E®   «E∞ÈËiPˇ¿%ÍiãM¯3¿3ÕË˚˙ˇ…¬ ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏVW3ˇjYã˜â}â}¯â}¸Ëı¥¸ˇÑ¿t ãUçBPˇ2ãR˜⁄j“É‚˝É¬YËï∂¸ˇãWjçEËâuËPâ}Ïˇp&Íi_^…¬ ÃÃÃÃãˇUãÏÉÏ ãUVj_XäJ3ˆfâE¯äBàE¸çE¯jP3¿âuËÑ…âuâuÙï¿àM˝@PçE¸P∑jPˇP$Íi∑E¯ôVâE‡çE‡jPâU‰ˇp&Íi^…¬ ÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏ<ãMçEƒÉe¸ âE¯«E$   ãAâEÃã	çUƒË?˝ˇÉeÏ j âEËçEËjPˇp&Íi…¬ ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏãMV3ˆâuâu¯âu¸ËÅ@˝ˇVjçEËâuËPâuÏˇp&Íi^…¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏãMÉe¸ «E$   âM¯Ëá@˝ˇÉeÏ j âEËçEËjPˇp&Íi…¬ ÃÃÃÃÃÃÃÃÃãˇUãÏÉÏV3ˆâuâu¯âu¸ãMËA˝ˇVâEËçEËjPâuÏˇp&Íi^…¬ ÃÃÃÃÃÃÃÃÃÃÃÃ3¿PPPˇp&Íi¬ ÃÃãˇUãÏÉ‰¯ÉÏãMV3ˆât$ât$ât$9qt
9quËV¸ˇˇãQãIË^ç¸ˇVjçD$ât$Pât$ˇp&Íi^ãÂ]¬ ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏÉÏãMV3ˆâuâu¯âu¸9qt
9quË¸˚ˇˇˇq(fãQ ˇq$ãIË∑O˝ˇVâEËçEËj     * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map