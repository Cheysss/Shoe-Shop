/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod}i‰EØ;ÆtPÿuàÿ êiÿuØÿ5€üéiÿ êi‰EØƒ} t2hb ÿ ‹uäVSWWÿ5€üéiÿÔ!êiÿuÿuÿ5€üéi‹MÿT0êiÿUë%ÿuÿuWWÿ5€üéiƒ}$ tÿ„ êiëÿˆ!êi‹uä‰EÜ…Àth  ú VSWWÿ5€üéiÿÔ!êi‹EÜ…Àuƒ}ÿuqW‹uàVÿ  êi‰EÌhÿÿÿ Vÿ êi‰EÈ‹MĞ…Éu‹|üéiQVÿ êi‹ğh  ¸ WWÿ5€üéiÿuäSÿuÿu‹}àWÿP êiVWÿ êiÿuÌWÿ  êiÿuÈWÿ êiÿuØÿ5€üéiÿ êiƒ}ÔÿtÿuÔSÿ5€üéiÿü êihÈÿéiÿ8'êi‹EÜë3À‹Mğd‰    Y_^[ÉÂ  ‹3À…Òt‰‹VR‹p‹ÎÿT0êiÿÖ^Ã‹3À…Òt‰‹VR‹p‹ÎÿT0êiÿÖ^Ãd‹   ‹Ü  …ÀyÈ3Ò98ıéitV‹±`  ‹Æd  t9V~B^‹ÂÃ3À@…Ét;Èt3ÀÃ3À@…Ét;Ètƒùt
jWÿ¬%êi3ÀÃ‹ÿU‹ìƒäøìD  ¡8õéi3Ä‰„$@  ‹ES·]VWRj	‰L$$Œ$@  Z‰D$èG¨ùÿD$ ‹ÓPD$PD$PD$$PD$PŒ$L  è÷   ‹L$‹ø…ÿ…–   9Eu÷Á   „Á   ƒáı„$8  ƒd$  º¨œài‰L$f‹0f;2uf…ötf‹pf;ruƒÀƒÂf…öuŞ3ÀëÀƒÈ…Àt>h¨œàij	ZŒ$<  è¦§ùÿj D$‹ÓPD$PD$$PD$PŒ$L  èY   ‹L$‹ø‹T$„$8  Qÿt$‹ÏPÿt$(D$0Pÿt$(èT.ÿÿT$ ‹Ï‹ğènèÿÿjYè]ƒüÿ‹Æ‹Œ$L  _^[3Ìèø%ûÿ‹å]Â ‹ÿU‹ìì(  ¡8õéi3Å‰EøS‹]V‹u·Â‰…èıÿÿW‹ù‹M‰Üıÿÿ‹M‰àıÿÿ‹M‰äıÿÿ…öth  j Vè‡eûÿ‹…èıÿÿƒÄ‹äıÿÿQSP‹×ìıÿÿèñÿÿ…ÀtVÿµàıÿÿ‹×‹ÈÿµÜıÿÿSè   ‹Mø_^3Í[èV%ûÿÉÂ ‹ÿU‹ìì´  ¡8õéi3Å‰Eü‹ESV‹u‹Ù‰…¨ûÿÿ‹EW‰…pûÿÿ3ÿ‹Eh  ‰…lûÿÿ…èûÿÿWP‰•xûÿÿ‰¤ûÿÿèädûÿƒÄWWSÿ<#êi‹ø‰½”ûÿÿé  ûì›ài„‡  jWÿ #êijW‰…˜ûÿÿÿ #êi‰…œûÿÿ…ötK‹…¨ûÿÿ÷     u*ÿô!êid‹0   9Ô  tÿä&êid‹0   9Ô  ujWÿ #êi‹Ø‰…°ûÿÿë3Û‰°ûÿÿ…Û„¬  j V‹ËÿT0êiÿÓ…À„—  ƒ>ƒ‹  ƒ¥ˆûÿÿ ƒ> vs‹½ˆûÿÿF  ‰…¬ûÿÿj €ûÿÿ3ÒQ„ûÿÿQÿµ¨ûÿÿ‹Èè¨şÿÿ™‰CøÂ‰Süt‹…„ûÿÿ‰‹…€ûÿÿ‰C‹…¬ûÿÿGƒÀHƒÃ‰…¬ûÿÿ;>r®‹½”ûÿÿ‹°ûÿÿh°¨ài…ŒûÿÿPÿ\'êi…ŒûÿÿÇ…Tûÿÿ   ‰…\ûÿÿ3É…Tûÿÿ‰XûÿÿPh  … ûÿÿÇ…`ûÿÿ@   P‰dûÿÿ‰hûÿÿÿP'êi…Àˆ¨   h<¨ài…ŒûÿÿPÿ\'êi…|ûÿÿPj…ÈûÿÿPj…ŒûÿÿPÿµ ûÿÿÿD'êi…Àx‹…Ôûÿÿ‰†  ƒ¾   tGh¨ài…ŒûÿÿPÿ\'êi…|ûÿÿPj…´ûÿÿPj…ŒûÿÿPÿµ ûÿÿÿD'êi…Àx‹…Àûÿÿ‰†  ÿµ ûÿÿÿL'êiëƒ& ƒ½œûÿÿ uƒ½˜ûÿÿ „H  ÿµxûÿÿƒ¥°ûÿÿ …Lûÿÿƒ¥¬ûÿÿ Pÿ\'êi…tûÿÿPj…LûÿÿPÿX'êi‹…¨ûÿÿ÷     uFÿô!êid‹0   9Ô  t1ÿä&êid‹0   9Ô  t…Üûÿÿj PèWìÿÿ…Àt
…Üûÿÿ3Éë‹¬ûÿÿ‹…°ûÿÿ‹•œûÿÿ…Òt#j QP…ğıÿÿ‹ÊPÿµtûÿÿÿT0êiÿ•œûÿÿ…Àu#‹…˜ûÿÿ…ÀtzğıÿÿQ‹ÈÿT0êiÿ•˜ûÿÿ…Àtaÿô!êid‹0   9Ô  t ÿä&êid‹0   9Ô  t…Ûuƒ  j j …ğıÿÿPÿ<#êi‹Ø…Ût…ğıÿÿW‰…¤ûÿÿÿH#êi‹ûjWÿ #êi‹Ø…Û…‚   3É…öt1‹Ù9v)¾ˆ  ƒûs‹Gtÿ7ÿL'êi3É‰‰OCƒÇ;rİ‰‹…¨ûÿÿ9}.¸ì›ài9…¤ûÿÿt!QQP‹Ø‰…¤ûÿÿÿ<#êi‹ø‰…”ûÿÿ…ÿ…ëûÿÿ3À‹Mü_^3Í[è½ ûÿÉÂ ‹ËÿT0êiÿÓ‹pûÿÿ+Ç‰…ötj ZRÿµ¤ûÿÿD  èÎ.ùÿ3Àf‰†‚  ‹lûÿÿjWƒ# ÿ #êi‹ğ…öt‹ÎÿT0êiÿÖ+Ç‰h  …èûÿÿPWÿ,#êiWÿH#êi3ÀPPjPjh   €…èûÿÿPÿ"êiéYÿÿÿÌÌÌÌÌÌ‹ÿU‹ì‹M÷Á ¢ÿÿthì  ÿ¬%êi3Àëè¡àÿÿPÿ`(êi]Â Ì‹ÿU‹ìƒäøƒì0‹E‹UVWj	Yp‹ |$ó¥‰D$L$3ÀÇD$0   jPP‰D$@èû2ùÿ_^‹å]Â ‹ÿV‹ñè²÷ÿÿ‹Æ^Ã‹ÿV‹ñèÁ÷ÿÿ‹Æ^Ã‹ÿV‹5têiQ‹ÎÿT0êiÿÖ^Ã‹ÿU‹ìV‹u…ÉtVè   ë¸  À…Ày…ötƒ& ^]Â ‹ÿU‹ìQV¾  W‹Ö3ÿf99tƒÁƒêuó‹M‹Â÷ØÀ%óÿÿ?  À…Ét…Òt+ò‰1ë‰9_^ÉÂ ‹ÿU‹ìQVEü‹ñPè™   …Àx*‹EÑè=şÿÿv¸W €ëP‹Eüºš   ÿu+ĞQFè   ^ÉÂ hşÿÿhĞ©àiQºš   è   Â ‹ÿU‹ì…Òt)‹EV‹u+ÁW…öt·<f…ÿtf‰9ƒÁNƒêuç_^…Òuƒé÷ÚÒâ†ÿø3Àf‰‚z €]Â ‹ÿU‹ìQV¾š   W‹Ö3ÿf99tƒÁƒêuó‹M‹Â÷ØÀ%©ÿøW €…Ét…Òt+ò‰1ë‰9_^ÉÂ ‹ÿU‹ìSVWÿurÿ‹ùÿu3ÛVWÿ'êiƒÄ…Àx
;Æwt	‹ğë»z €3Àf‰w‹M…Ét‰1_^‹Ã[]Â ‹ÿU‹ìÿuèaÿÿÿ]Â 3ÀÂ ‹ÿV‹5lêiW‹ù‹ÎÿT0êi‹ÏÿÖ_^Ã‹ÿU‹ìQƒeü EüVPÿu‹òÿØ%êiƒ=´õéi u3Àë&ƒ}ü uVj ÿ\-êi3À@ëh   èbfúÿÁè÷Ğƒà^ÉÂ ‹ÿU‹ìƒìSV3ö‰UôV‹ÁVP‰Eüÿ| êi‹Ø‰]ğ…Ût~WÁàPVÿÀ"êi‹ø…ÿtkWSÿuüÿ| êi…ÀtU‹G…À~)‹ğ_ ‹Eÿ°   ÿ°   ÿuôSÿà(êiƒÃƒîuß‹]ğWSVÿx êi‹Ø…ÛtjVSÿuüÿ¨ êiS‹ğÿH êiWÿ¼"êi_‹Æ^[ÉÂ ‹ÿQ2ÒèŠúúÿYÃÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì]ÿ%(êiÌÌÌÌ‹ÿU‹ìjJÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQ¡üéi‹üéiSVW·ø;Áw·ù‹uÁè@‰}üPÿ5üéiVèõ[ûÿ¡$üéiN‹ üéiƒÄ‰Eø3Û¡üéiÁèÈ‹Á+Æ;ÎÉ÷Ñ#Èv‹}øŠƒÂƒ× FC;Ùrğ‹}üf‹Ç_^[ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌjè5ûÿÃÌÌÌÌÌÌÌÌ‹ÿU‹ìj.ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjiÿuÿh*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U3À‹Mhà©çiPPPèÙşÿ·À]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ}Vu\ƒ}uV‹MèVúÿ‹ğ‹ÎÊu3ÀëSöFu<·F*%ÿ?ÿÿ=¢  u,RVèuŸúÿ…Àt!‹†(  ‹‹H‹ÂÁt÷BP @  u‹B@‹ ëj ÿuÿuÿuÿ0êi^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹MèÓúÿ‹ÈÊu3Àëö@ ujÿuÿH+êi3À@]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj j ÿuÿuÿuÿuÿuÿuè   ]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìSV3Û3ö9]$tjWÿ¬%êi3ÀéÊ   ÿuEøPÿ@&êijEøPEğPÿD&êi…Ày
Pÿà&êiPëÈW‹}…ÿt=WEøP]èÿ@&êijEøP‹ÃPÿD&êi…ÀyPÿà&êiPÿ¬%êiEğPÿà%êi3ÀëY9utÿuÿ êi‹ğÿu ‹ÓMğÿuÿuÿuVè!Üÿÿ‹ØEğPÿà%êi…ÿt
EèPÿà%êi…ötd¡0   Vj ÿpÿd'êi‹Ã_^[ÉÂ  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìEğVÿuPÿ\'êi‹uEøVPÿ\'êiÿu ÷ŞUøÿuöMğÿu#Öÿuÿuè–Ûÿÿ^ÉÂ  ÌÌÌÌÌÌÌ‹ÿU‹ìj j ÿuÿuÿuÿuÿuÿuèÿÿÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒäøƒìD$VÿuPÿä%êi„Àu3Àë!ÿu‹UL$ÿuè‘Ûÿÿ‹ğD$Pÿà%êi‹Æ^‹å]Â ÌÌÌÌÌÌ‹ÿU‹ìQQÿuEøPÿ\'êiÿu‹UMøÿuèPÛÿÿÉÂ ÌÌÌÌÌÌÌ‹ÿU‹ìjÿu(ÿu$ÿu ÿuÿuÿuÿuÿuÿuÿ°)êi]Â$ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjèuûÿÃÌÌÌÌÌÌÌÌ‹ÿU‹ìjKÿuÿT*êi]Â èŒùÿPÿà&êi…À~·À  €ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjhÿuÿuÿ¬*êi]Â ÌÌÌÌÌÌÌÌÌj)èûÿÃÌÌÌÌÌÌÌÌ‹ÿU‹ìh‹   ÿuÿuèóûÿ]Â ÌÌÌÌÌÌÌ‹ÿU‹ìj ÿ¬%êij1ÿuÿT*êi]Â ÌÌÌÌ‹ÿU‹ì‹U‹Mjÿuÿuèáÿÿ]Â ÌÌÌÌ‹ÿU‹ì‹U‹Mj ÿuÿuèìàÿÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì‹E‰Eğ‹E÷ØÇEì   ÇEø   Àƒeü ƒà‰EôEìPÿ$/êiÉÂ ÌÌÌÌÌ‹ÿU‹ìjQÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì3À9E•ÀPÿœ+êi]Â ‹ÿU‹ìƒìd¡8õéi3Å‰EüSVWEÈ‹ùPh   ÿT'êi…Àˆh  h@àiEÌPÿ\'êi‹EÈ3Û‰E°EÌj^‰E´E¬Ph  EÔ‰u¬PÇE¸@   ‰]¼‰]ÀÿP'êi…ÀEÌxthpàiPÿ\'êiE¨Pj$EØPjEÌPÿuÔÿD'êiˆûÿÿ÷ÙÉ#È‹Ï|EäPëh¨œàij	Zèì–ùÿÿuÔÿL'êiÿuÈÿL'êi¡(üéiö „Å  ‹ÏèUÖÿÿé¹  h àiPÿ\'êi‹EÈ‰E°EÌ‰E´E¬Ph?  EÔ‰u¬PÇE¸@   ‰]¼‰]ÀÿP'êiÿuÈ‹ğÿL'êi…öˆ\  ¾àiEÌVPÿ\'êiE¨Pj$EØPjEÌPÿuÔÿD'êiˆûÿÿ÷ÙÉ#È‹ÏŒ  EäPj	Zè)–ùÿ¡(üéiö t4jSWÿÔ%êi%ÿ  ƒÄfƒøuhtàiëfƒøuhˆàij	Z‹Ïèë•ùÿh zàiEÌPÿ\'êi‹EÔ‰E°EÌ‰E´E PSSSE¬ÇE¬   Ph  EÄÇE¸@   P‰]¼‰]ÀÿĞ%êi…ÀyÿuÔÿL'êié‰   hpàiEÌPÿ\'êi‹ÏQf‹ƒÁf;Ãuõ+ÊÑùM   PWjSEÌPÿuÄÿÌ%êi…ÀyÿuÔÿL'êiÿuÄë§VEÌPÿ\'êiEÌPÿuÔÿÈ%êiëØh¨œàij	Zè•ùÿéxÿÿÿh¨œàij	Z‹Ïè•ùÿ‹Mü_^3Í[èÃûÿÉÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹M2Òèœñúÿ…ÀuƒÈÿëƒà]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…Àu]Â ]ÿ%„(êiÌÌÌÌÌÌÌÌÌ‹(üéi·t  ·‰p  ÁàÁÃÌÌÌÌÌÌ‹ÿU‹ì]ÿ%x(êiÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹M2Òèìğúÿ…ÀtÁè%ÿ  ]Â ‹ÿU‹ìƒ} Vt·që3öf‹AfÆf#Â^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌjè%ûÿÃÌÌÌÌÌÌÌÌÿ%d#êiÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìÿô!êid‹0   9Ô  taÿä&êid‹0   9Ô  tLEôj PèÜÿÿ…Àt‹Eƒè t0ƒètƒèt-üÿÿtƒèt	3Àë&‹Eüë!ƒ}ôu·Eøë‹Eøë‹Eôëj3ÿuÿT*êiÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjVÿuÿ€)êi]Â è‡9úÿ…ÀuÃ‹@<ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj4ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌd‹   ‹Ü  …ÀyÈ‹AxA|VujÿÄ*êi…Àt/d¡   ‹ˆÜ  …ÉyÁ‹ˆ   ‹q(‹Q,‹ÎÊt‹€(  ‹^Ã3À^ÃÌÌÌÌÌ‹ÿU‹ìj-ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌd‹   ‹Ü  …ÀyÈ‹AxA|VujÿÄ*êi…Àt/d¡   ‹ˆÜ  …ÉyÁ‹ˆ   ‹q ‹Q$‹ÎÊt‹€(  ‹^Ã3À^ÃÌÌÌÌÌd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…ÀuÃd¡   ‹ˆÜ  …ÉyÁ‹€ğ  ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjèåûÿÃÌÌÌÌÌÌÌÌ‹ÿU‹ìÿu‹Eÿuÿuÿ0ÿuÿğ%êi…ÀyPÿà&êiPÿ¬%êi3Àë3À@]Â ÌÌÌÌÌÌÌ‹ÿU‹ìj5ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjWÿuÿ€)êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…Àt%‹MVèÛƒúÿ‹ÈÊt‹°$  ëjWƒÎÿÿ¬%êi‹Æ^]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjuÿuÿh*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U‹Mjÿu(ÿu$ÿu ÿuÿuÿuÿuèLäÿÿ]Â$ ÌÌÌÌÌ‹ÿU‹ì‹U‹Mj ÿu(ÿu$ÿu ÿuÿuÿuÿuèäÿÿ]Â$ ÌÌÌÌÌjÿÄ*êiÃÌÌÌÌÌÌÌ‹ÿU‹ì‹MV3öèƒúÿ‹ÈÂt¶±ë   Ñîƒæ‹Æ^]Â ÌÌÌÌÌÌÌd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…ÀuÃd¡   ‹ˆÜ  …ÉyÁ‹€à  3Éƒà@ÁtA‹ÁÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌjèÕûÿÃÌÌÌÌÌÌÌÌ‹ÿU‹ì‹Mès‚úÿ‹ÈÊujWÿ¬%êi3Àë¶€ê   Áèƒà]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹M2Òèüëúÿ÷ØÀ÷Ø]Â ÌÌÌÌÌÌÌ‹ÿU‹ì‹Mè‚úÿ‹ÈÊujWÿ¬%êi3Àëö€é   u	€¸ê    }ê3À@]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ìì  ¡8õéi3Å‰Eü‹EôıÿÿV‹uW3ÿ‰ğıÿÿWh  ğıÿÿQjÿPWèß5ùÿ…ÀtWVW•ôıÿÿ3Éè
æÿÿ‹Mü_3Í^èLûÿÉÂ ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹M…Éu3Àë‹Uj ÿuj èĞåÿÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U3Éj ÿuj è©åÿÿ]Â ÌÌÌÌÌÌj7j ÿT*êiÃ‹ÿU‹ìƒì$¡8õéi3Å‰EüVÿô!êid‹0   9Ô  tÿä&êid‹0   9Ô  t3öFëj^VhğyàiEôjPè&¿úÿƒÄEàhøyàij	PhTzàiEôPh zàiÿ´#êiƒøÿt#fƒ}à tj h’   j Uà3ÉèıäÿÿFşè  r¥‹Mü3Í^è7ûÿÉÃÌÌÌÌÌÌÌÌj7jÿT*êijÿ€ êiÃÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj6ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj9ÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjaÿuÿuÿ¬*êi]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQÿuEøPÿä%êi„Àu3Àë!‹UMøVÿuÿuèhÑÿÿ‹ğEøPÿà%êi‹Æ^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQÿuEøPÿ\'êiÿu‹UMøÿuè!ÑÿÿÉÂ ÌÌÌÌÌÌÌ‹ÿU‹ì‹MèSúÿ‹ÈÊu3Àëö@ tjÿuÿH+êi3À@]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQÿuEøPÿä%êi„Àu3Àë‹UMøVÿuèüĞÿÿ‹ğEøPÿà%êi‹Æ^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQÿuEøPÿ\'êiÿu‹UMøèµĞÿÿÉÂ ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ} uƒ} ujOÿuÿT*êië
jWÿ¬%êi3À]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìh„   ÿuÿuè£	ûÿ]Â ÌÌÌÌÌÌÌ‹ÿU‹ìh‚   ÿuÿuèƒ	ûÿ]Â ÌÌÌÌÌÌÌ‹ÿU‹ìjbÿuÿuÿ¬*êi]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ} uj>ÿuÿT*êi]Â ÌÌÌÌÌÌ‹ÿU‹ìh…   ÿuÿuè#	ûÿ]Â ÌÌÌÌÌÌÌ‹ÿU‹ìjgÿuÿuÿ¬*êi]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjBÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjÿuj jè]xùÿ]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjDÿuÿT*êi]Â ‹ÿRQÿÔ+êiÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ3À@Â ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjwÿuÿuÿ¬)êi]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjFÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj\ÿuÿd(êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjSÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìÿuÿuÿŒ+êi]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjRÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj]ÿuÿd(êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…ÀuƒÈÿëI‹MV…ÉtƒùtjWƒÎÿÿ¬%êië,d¡   ‹Ü  …ÒyÂ‹°ğ  ;ñtÇ€ô     ‰ˆğ  ‹Æ^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìd‹   ‹Ü  …ÀyÈ‹AxA|ujÿÄ*êi…Àth‰   ÿuÿuè¼ûÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ}u0ÿä#êi;Euƒ}u‹E¹´õéi‹ ‡3À@]Â jWÿ¬%êi3Àëğ]ÿ%@(êiÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì]é¥ÿÿÿÌÌÌÌÌ‹ÿU‹ì‹Eÿuÿ0ÿuÿì%êi…ÀyPÿà&êiPÿ¬%êi3Àë3À@]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjHÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQ‹MEüPèØæÿÿ…Àxÿuüÿuÿuÿ€(êië
jWÿ¬%êi3ÀÉÂ ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjIÿuÿT*êi]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìj j ÿuÿT(êi]Â ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì]ÿ%T(êiÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìjzÿuÿuÿ¬)êi]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U3À‹MhÀ®çiPPPèÎÃşÿ·À]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìEøSVW‹}WÿujPÿuÿuÿuèªùÿ‹Ø™‹ğ3ò+òtW;=pêit)jEüPh  ·ÇPÿh#êi…Àt2‹Eü£têi‰=pêië¡têiMôQj jÿuMøVQj Pÿ\$êi…Àu3Àë…Ûy÷Ş‹Æ_^[ÉÂ ÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹MèóxúÿÂujWÿ¬%êi3Àëÿu$‹E ƒÈPÿuÿuÿuÿuÿuèõùÿ]Â  ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìhŠ   ÿuÿuèóûÿ]Â ÌÌÌÌÌÌÌ‹ÿU‹ìÿuÿh(êi…Àt3ÉAè•aüÿ3À@ë3À]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQQƒMøÿEøPjÆEü ÿÜ%êi…Àˆ‡  €}ü „}  ‹MÇ`üéi³åiÇhüéiğ!èi‹£Xôéi‹A£Tôéi‹A£Pôéi‹A£Lôéi‹A£Hôéi‹A£Dôéi‹A£@ôéi‹A£xêi‹A £têi‹A$£pêi‹AH£Üêi‹AL£Øêi‹A(£düéi‹A,£\üéi‹A4£dôéi‹A8£`ôéi‹A0£\ôéi‹AD£àêi‹A@£äêi‹AP£Ôêi‹A`£Èêi‹A\£lêi‹AT£Ğêi‹AX‹M£Ìêi¡<(êi‰A<¡X(êi‰A@¡\(êi‰AH¡ü)êi‰AP¸ğùéiÇ   
ÇA@íçiÇA ¯èiÇA0²æiÇA úçiÇA ëçiÇA`ÅèiÇA ÛèiÇA °ºâiÇA$ ´åiÇA(ğºåiÇA,ĞÈèiÇA0àÈèiÇA4 èiÇA8³åiÇAD ®æiÇAL ÉèiÇATXàië¸"  ÀÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìEèS‹]j jPj Sÿô%êi…Ày-=$  ÀuöÃtjÿuƒãüSëöÃt3Àëjÿ¬%êiƒÈÿëj ÿuÿuøÿ4(êi[ÉÂ ‹ÿU‹ì‹M3Àf9  •À]Â ‹ÿU‹ìQSVWEü3ÿPW‹ñ‰}üÿ(°êi…Àu9V»ˆŠáiShxŠáiÿuüWÿ4°êi…ÀuVShxŠáiÿuüWÿ8°êi…Àu
ÿuüWÿ$°êi3Û…À”Ã9}üt	ÿuüÿ¼"êi_^‹Ã[ÉÃ‹ÿU‹ì3ÀV…Òt*‹uSW‹}+ñ…ÿt·f…Ûtf‰ƒÁO@ƒêuæ_[…ÒuƒéH÷ÚÒ3öf‰1â†ÿø‹M^…Ét‰‚z €]Â ‹ÿU‹ì3À…Òt;Uv¸W €]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìd‹   ƒì‹Ü  …ÀyÈSV‹u‹ÆEWj Zu‰Uüë‹‰Eü‹E‹}‹u‰Eô‰}ø‰uğ‹h  ‰Eìd¡   ‹ˆÜ  …ÉyÁ‹€   ƒàÂt3ÒBÿuEìPRh   è\½úÿ‹Ï‹Øèrúÿ…ÀtVè)Úüÿëÿ  uVè©®üÿ_^‹Ã[ÉÂ ‹ÿU‹ì‹Uƒì‹ÂEj Yu‰Müë‹‰Eü‹ES‰Eôd¡   V‹uW‹}‰}ø‰uğ‹Ü  …ÒyÂ‹€   ƒàÁt3ÉAÿuEğPQh   èÈ¼úÿ‹Ï‹Øèúqúÿ…ÀtVè•Ùüÿëÿ  uVè®üÿ_^‹Ã[ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒäø‹UD$Ğ‹Mƒì0PÿuÿuèaÑşÿ‹M$j Pjh   ƒÊÿè„ıøÿ‹å]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U‹Mj ÿuÿuÿuÿuèëÿÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹U‹Mj j ÿuÿuÿuè¼ÿÿ]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì3Àƒ}”ÀH]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì]ÿ%¬(êiÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹MVèârúÿ‹ğ‹ÎÊt'‹F ™9F u9V$uÿuÿuÿv ÿ,#êië
j~ÿ¬%êi3À^]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒäø‹MD$Ğƒì4V‹u‹ÖPÿuÿuèĞşÿ‹UD$‹Mæ   j PjVè>üøÿ^‹å]Â ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒäø‹MD$Ğƒì4V‹u‹ÖPÿuÿuèÎÏşÿ‹UD$‹Mæ   j Pj Vèîûøÿ^‹å]Â ÌÌÌÌÌÌÌÌÌÌjèEıúÿj ÿô#êiÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìhƒ   ÿuÿuè#ıúÿ£dêi]Â ‹ÿQjÿ5èùéiÿh'êiÃ‹ÿQj ÿ5èùéiÿd'êiÃ‹QV3öÑ9qv‹RF;qrò^Ã3Àƒùw=tOƒùv2ƒùtEƒùt$ƒùu‹J+ÈtƒétIƒét	ƒéujXÃjXÃjXÃjXÃƒùtëƒù
tƒùtíƒùÿußjXÃƒzuÕëØ‹ÿU‹ìƒì(j j(EØÇEü   Pjjÿÿô%êi…Àx‹EØÉÃ3ÀÉÃ·Á¯ úéiøùéi™ÃÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìV‹uW3ÿ‰}ğ‰}ø‰}ü9~t9~u‹Îè	ÿÿÿ‹N(F$÷ÙÉ#ÈQÿv ÿvÿp êiW‰EèEèjP‰}ìÿp&êi_^ÉÂ ÌÌÌÌÌ‹ÿU‹ìƒì\¡8õéi3Å‰EøjPE¤j Pè<ûÿƒÄÇE¤  ÀE¤ÇE¨   ÇE°éèiPÿÀ%êi‹Mø3À3ÍèğûúÿÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìVW3ÿjY‹÷‰}ğ‰}ø‰}üèõ´üÿ„Àt ‹UBPÿ2‹R÷ÚjÒƒâıƒÂYè•¶üÿ‹ğWjEè‰uèP‰}ìÿp&êi_^ÉÂ ÌÌÌÌ‹ÿU‹ìƒì ‹UVj_XŠJ3öf‰EøŠBˆEüEøjP3À‰uè„É‰uğ‰uô•ÀˆMı@PEüP·jPÿP$êi·Eø™V‰EàEàjP‰Uäÿp&êi^ÉÂ ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì<‹MEÄƒeü ‰EøÇEğ$   ‹A‰EÌ‹	UÄè?ıÿƒeì j ‰EèEèjPÿp&êiÉÂ ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì‹MV3ö‰uğ‰uø‰uüè@ıÿVjEè‰uèP‰uìÿp&êi^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì‹Mƒeü ÇEğ$   ‰Møè‡@ıÿƒeì j ‰EèEèjPÿp&êiÉÂ ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒìV3ö‰uğ‰uø‰uü‹MèAıÿV‰EèEèjP‰uìÿp&êi^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌ3ÀPPPÿp&êiÂ ÌÌ‹ÿU‹ìƒäøƒì‹MV3ö‰t$‰t$‰t$9qt
9quèVüÿÿ‹Q‹Iè^üÿVjD$‰t$P‰t$ÿp&êi^‹å]Â ÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì‹MV3ö‰uğ‰uø‰uü9qt
9quèüûÿÿÿq(f‹Q ÿq$‹Iè·OıÿV‰EèEèj     * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map