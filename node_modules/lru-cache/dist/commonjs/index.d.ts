/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdaëh¾  ÿ5˜üéiÿT0êiÿÖE´Ç…pÿÿÿ0   ‰E”¹ÿÿ  …pÿÿÿÇ…tÿÿÿB   PjQW‰M˜ÇE€'  èÒ†ûÿC¸  f9E¬„–   ‹5€óéi‹Îjÿu°ÿT0êiÿÖ‹5hüéi‹Îj j ‰E¬E´PhÁ  ÿ5˜üéiÿT0êiÿÖƒ¥|ÿÿÿ E´öE¹ÿÿ  Ç…pÿÿÿ0   Ç…tÿÿÿC   ‰E”‰M˜ÇE€'  u
‹E¬ƒà<t
Ç…|ÿÿÿ   …pÿÿÿPjQWè-†ûÿC‹Eƒàt7…Ût3…pÿÿÿÇ…pÿÿÿ0   P‹E¨jPWÇ…tÿÿÿ   Ç…xÿÿÿ   èï…ûÿë…Àu…Ûu‹E¨h   HPWÿ¸/êiÿu¤‹5óéi‹Îÿu ÿT0êiÿÖépıÿÿ3À‹Mø_^3Í[è×‡ıÿÉÂ ‹ÿU‹ìì¤   ¡8õéi3Å‰EüSVW‹ò‰u‹Ñ‰UÌ‹E 3ÿ‰EĞ‹Ç‰}°‰}¤‰}€‰}„‰}Œ½\ÿÿÿ‰E¼‰Eˆ«‹M‹],«‰u¬‹u«‰MØ‰]”ÇEÄ   «3À3ÿƒ}( ‰}¨‰}´‰½pÿÿÿ‰}œ‰} }à«««t,ƒc R‰sÿ”!êiƒøtƒ}(tƒe¤ ëÇE¤   ‹UÌ‹MØ‹}Ğ‹E‹]‰Eì‹‡¤   Ã‰uô‰]ğ‰Eø…É„<  ‹u…ö„1  ‹‡    ‹]‰…tÿÿÿ‹‡¸   ‰]È…Àt‹ë3Ò‰U˜…ÀtƒÀ‰…xÿÿÿƒúu‹ ‰E°…Àu@ë‹…tÿÿÿƒ¥xÿÿÿ Áà‰E°Ç…lÿÿÿ€   Ç…|ÿÿÿ	   …ö„V  ‹Gh‹—¼   %  @ ‹ŸÌ   ‰]Ô‰UÀ…Ò„U  ‹MĞ3ÿ‰uÜ÷Ah    ‹MØ„  3É3Û‰MÔ…Àt}…öò   ‹EØŠ<	„á   ¶ğ¸€   ;ğskÆ‹LëEàPVVÿuÌÿT!êi‹MàMä‹UÀÏ;MÔv‰MÔ¸€   ;ğs	kÆ‹|ë‹}èù‹MÔ;ùv‹Ï‰MÔ‹uC;Ş|ë}…ö~y‹EØ·Xf;…|ÿÿÿtf‹ğ¸€   ;ğskÆ‹LëEàPVVÿuÌÿP!êi‹MàMä‹UÀÏ;MÔv‰MÔ¸€   ;ğs	kÆ‹|ë‹}èù‹MÔ;ùv‹Ï‰MÔ‹uC;Ş|Œë‰]Ü+Ï‰MÔ‹Ùé'  3ö…À„   ‹M…É  ‹EØÆ‰E¸Š€ú	„ö   ‹]Ğ÷Ch   t/^;Ù}(‹MĞè\pûÿ…ÀtEœPjÿu¸ÿuÌÿH!êi}œ‹óë*‹E¸¹€   :ÑrMœQjPÿuÌÿH!êi}œë	‹MÀ¶Â<‹MF;ñ|ƒéŠ   9u„   q·j	Y‰U¸f;Átm‹ØAwf;ØrI‹E‹Î‹UØf;|ÿÿÿt;ğ}F·rf;lÿÿÿså‹U¸EœP‹Æ+ÁPRÿuÌÿ¤!êi}œj	Xf;Øt;u}‹EĞ·Ë‹€¼   <ˆF;u}‹MØë‚‰uÜ‹]Ô‹u+uÜëL‹Ö…Àtèºóÿÿ‹øEœPWÿuØ‰}ÜÿuÌÿH!êiëè¶óÿÿ‹ø‰EÜEœPWÿuØÿuÌÿ¤!êi‹EĞ+÷‹}œ+¸¨   ‹UÈ‹Ê×‰uƒ}Ä ‹ú‰MÀ‰UÈ‰}¸tEƒ}( t?;E¬~‰E¬ë‹E¬;E~*‹]”ƒ{ u!‹EØ‹}”‰‹E‰C‹]Ü3‰G‹Ç‹}¸‰Hë‹]Ü‹EĞ‹MØ‹@h©  @ t
Ë‰M¨‹M´ëY‰M´3Û…ö„  ‹}Ü©  @ t‹M¨3À€9	”Àë
j	Xf9t
3À…À„ç   ‹M°‹ò…Ét+U$‰UÈ‹Â™÷ù)UÈ‹UÈÑëL‹E˜3É…À~%‹…xÿÿÿ‹}Ü‹ˆE$;Ğ|
‹E˜A;È|åë‹Ğ‹E˜‰UÈ;Èu +U$‹tÿÿÿ‹ÂÁá™÷ù‰M°P¯ÑU$‰UÈƒ}Ä tFƒ}( t@‹E¬;Ğ~‹Â‰E¬;E~/‹M”ƒy u&;E‰A‹E‰A‹EĞ÷@h  @ ‹E¨u‹E´‰‰q‹EĞC‹u‹M´N‰u‹@h©  @ tÿE¨ëƒÁ‰M´…ö…óşÿÿ‹}¸ƒ}( „É  ‹MÄ…Ét…öu‰Uô‹UÀë]‹EĞ‹ò+÷‹}Ô‹ˆÄ   9;Æv4‹MÜ…\ÿÿÿPÿu‹EËÁP‹EĞ·@r¯Á‹MÌEØPR‹UĞèG  ‹UÈ‹È9;ÆwG+Ñ‰Uô‹UÀ‹MÄ‹E9Eì+  …É„³   ƒ} …¡   ¾ü  ;Æ…”   9uô“   ‰uôé‹   ‰Uô;şv3ƒ}¼ ‹EÜt‹u„+ÆE‰E¼‰Eˆë ‹UØ‹u‰U€‹UÀ‰E¼‰Eˆ‰u„‰UŒë	‹E¼‹u„‹UÀ…É„vÿÿÿ‹MÄ…Àt‹…dÿÿÿ+Æ…`ÿÿÿ‰E¼‰EˆéYÿÿÿµ\ÿÿÿ}€¥¥¥¥‹Eˆ‰E¼éAÿÿÿ9Eô|‰Eô‹Eì;Eô}h‹EĞ÷@h  @ t.…Ét
ƒ}¤ tjëj‹uÜMìXj VÿuØQPÿuRÿuÌÿ<!êië1…Ét
ƒ}¤ tjëj‹uÜMìXj VÿuØQPÿuRÿuÌÿ¨!êië‹uÜƒ}Ä t‹Eô‹M‰Eì;Á‰Mì3‹uE‹}Ğ‹MÜË·Gr¯ÈMØ‹MØ…ö…­ùÿÿ‹]Èƒ}Ä tHƒ}( tB‹u¼…öt;jÿuÌÿ êi‹M€‹]ŒƒeÄ ‰…pÿÿÿ‹E‰Eì‹E‰Eô‹E„‰u‰MØ‰E‰]ÈéTùÿÿ‹…pÿÿÿ…Àt
PÿuÌÿ êi+]‹Ãë+ƒ}( t#j j hTzàiEìP‹E¤E   PSÿuRÿ¨!êi3À‹Mü_^3Í[èˆıÿÉÂ( ‹ÿU‹ìQ‹EVW‹ñ%    j Y•Áƒâu÷E   tjZ3ÿ…Àt‹Â+Çt
Hƒèu‹×ëjZ‰Vx‹Vh‹ÂÁè;Èt@ÁáâÿÿÿÊ3Ò‰Nh÷Á @  ‹ÎtWWWWèØUûÿ‹ÎèÒQûÿë
jWjÿè½_ûÿ3Ò‹ÎBèÎnûÿ_^Y]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹MSWèóüÿ‹ø‹Ú‹ÏËu3ÀëHV‹u;5Èúéiw+¡Ğúéi3Ò‹ÎBƒáÓâ‹ÎÁé„tj ÿuÿuVSWèîFûÿëj ÿuÿuVSWè±üÿ^_[]Â ‹ÿU‹ìƒì,¡8õéi3Å‰Eü‹ES‹]‰EÜ3ÀV‹uW}ğ‰MÔ«3É‰]è‰uä‰uØ«‰Mì«‹}Ü‹E‰w‰‰O‰G÷Bh    u,9Š¨   u3Àés  ‹ŠÈ   ‹E;Á|‹Á‰G‹‚¨   éV  ‹‚È   ‹};ø|‹ø‹‚¼   ‰Eà…Àu‹EÜ‰x‹‚    ¯Çé&  ÷Bh  @ „   …ÿ  3ÉA+Ë‰MìŠ¶Ø<	uFëcû€   s‹UàkÃ4ëEğPSSÿuÔÿT!êiuğ‹Uà‹Mì;uä}‰uä;uØ}‹EèÁ‹MÜ‰Aû€   skË‹DDë‹EøEô‹Mìğ‹]èC‰]èƒïu…éƒ   …ÿ~·‹Øƒø	uFëaû€   s‹UàkÃ4ëEğPSSÿuÔÿP!êiuğ‹Mì‹Uà;uä}‰uä;uØ}	A‹MÜ‰Aû€   skË‹DDë‹EøEô‹Mìğ‹]èƒÃA‰]è‰Mì;Ï|‹EØ+Eä‹Mü_^3Í[è|ıÿÉÂ ‹ÿU‹ìƒìSVW‹ò‹ù‰uø‰}ğèáWûÿ‹ØG|ƒÇ‰Eüƒ} ‰}ôuKjÿ7V‹0‹ÎSÿT0êiÿÖ…Àu'‹Eğ‹uø÷@h  @ t3À€<3ë	jY3Àf9s•À…Àu‹uüjÿ7ÿuø‹6ë‰Eü‰}ôë‹Eüj ÿ7V‹0S‹ÎÿT0êiÿÖ‹Mô‹ø‹Uü‹1G;Ær‹Æ‹Mğ÷Ah  @ t€<u1…ÿt€|ÿt€|ëjYf9{u…ÿt
f9L{şuOëf9L{u@jV‹2‹ÎPSÿT0êiÿÖ‹Mğ‹ğèCWûÿ‹M…Ét‰9‹E…Àt‰0_^[ÉÂ ‹ÿU‹ìV;Êr‹ñ+òëƒÎÿ;Ê‹MÀ%€‰1^]Â ‹ÿU‹ìQV‹ñEü3ÉQPQQÿÌ&êi…Àx
3À9uü”Àë3À^ÉÃ…ÒtQŠA„Àuù+ÊëQf‹ƒÁf…Àuõ+ÊÑù‹ÁÃ‹ÿU‹ìQQSV‹ñ3ÛW‰uü9^x„   ‹Uè‚Yûÿ‰Eø…ÀtU‹Îè3Vûÿ‹Nt‹ø‹E·Vr¯‹Îú3ÒBèÍbûÿSSSÿuü‹ğ3ÒSÿuø‹ÎWSSSè»òÿÿ‹Ö‹ø‹uü‹Îjèyeûÿ‹Îè6Vûÿë‹û‹FP+FH+Çy‹Ãƒ~xuÑèëƒ~xuƒèx‹Ø‹Ãë3À_^[ÉÂ ‹ÿU‹ìQQSV‹ñ‰UüW3ÿ¶Ú÷Fh  @ u·ÚöFh…ë  fƒû„á  3Òè‡êÿÿè]êÿÿ÷Fh   ‹Èj	ZjXt#ƒùtf;Ú„¶  f;Øu‹F@ö@„¤  jX÷Fh   jZtf;Ú…Œ  ƒù…ƒ  ·Ój Yƒúrƒú	v4ƒú
„ˆ   f;Øt&f;Ùr2÷Fh   t‹F@ö@ t‹ÎèËÚÿÿ…À„ò   ‹Îè¤Oûÿj Y…Àt3ÿG·Ãƒè„  ƒè„æ   ƒè„Ö   Hƒè„±   Hƒè„    jXf;Øu÷Fh  @ tÇEü
  ë)‹ØëŸÇEü 
 f;Ùsf;Øtj	Xf;Øtfƒûtfƒûuljè_xıÿ÷Fh  @ t/ŠÓ‹Îè9dûÿ…Àt‹N8‹Óèíâÿÿ·À…Àt‰Eüë‹EüÁè3É„Àë‹Eü3ÉÁèf…À•ÁUüAjQ‹ÎèéKûÿë\¸  ëH‹F;Fuj9j ÿT*êiëA¸   ë-¸  ë&…ÿu/9~t*‹V‹Îjèi  ‹Î‰Fè€Nûÿë¸  j j Pÿv8è1Äüÿ_^[ÉÂ ‹ÿU‹ì3ÀPPPÿuPÿuRPPP3Òè8ğÿÿ]Â ‹ÿU‹ìƒìSV‹u‰Uü‹ÖW‹ùèUXûÿ‹Ø‹Ï+G$¯‡¤   GL‰EøèDSûÿƒ} ‹Ğ‰Uğ„±   …Û„©   ‹Gt;4˜…   ƒşr3·GrNş¯È3À÷Gh  @ t€<ë
j^f94‹u·Or”À‰Mô…Àt3ƒşr`·GrNÿ¯È3À÷Gh  @ t€<
ëfƒ<
·Or”À‰Mô…Àu2‹wtK‹Eø‹Ó+‡¤   ‹Ï‰Eø‹4èÛUûÿ‹Ğ‹Eô·È¯Î‹uğ‰Uìé„   ·Gr‰Eì‹Gt‹˜·Gr¯È·Gr¯ÆÂ;wsK÷Gh  @ t!…öt>¾
  f9pÿ‹uu0Hƒşv*€xÿu$Hë!…ötxş 
 uƒÀşƒşvj^f9pşuƒÀş‹ò1;Âs‹Â+Â3Ò÷uì‹Ğ‰Eì1‹·ä   ‰Eğ…öt#R‹Ó‹Ïè'Uûÿ‹v‹ÎPÿuğÿuüWÿT0êiÿÖ‹ğë;3ö9wxt‹Uü‹ÏSèXûÿÿ‹Ø‹Eğë‹_,÷Û‹Mü3ÒVVVWVÿuìPVVVèVîÿÿ‹wHğó‹ÏèÚQûÿ‹E‹Mø_‰0^‰H[ÉÂ ‹ÿU‹ìƒì(SVW‹ù‰UğöGhw‹G‰Eì‰Eü‹G‰Eä‰Eø‹‰Eè…  è*æÿÿ‹Ğ3Û‹Eğ‰Uôƒø$‡¢  „G  ƒø	„
  ƒø„Š  ƒø„U  ƒø„,  ƒø †É  ƒø"vlƒø#…»  ‹Âƒà‰Eàt‹Gë‹W ‹ÏèTûÿ‹W ‹Ot‘‹Uô‰Eü‰öÂ„Õ  ‹Uä9Uè…Ğ  9Uì„Ç  ‹O9]àt‰Møé·  ‰Eø‰Müé¬  öÂuw3Ò‹ÏBè0]ûÿ‹ğ3ÛEÜ‹ÖPSÿw‹Ïèîüÿÿj‹Ö‹Ïèå_ûÿÿEà3Àƒ}ğ!S•ÀƒÀPh  ÿw8èÏÀüÿ‹]ôEÜƒãPÛº  S‹Ïèù  EÜº  PS‹Ïèè  éÜ  ‹GP+GH™÷¿    ƒ}ğ!Hÿu3ÉA+È·ÁÁàj ¶   Ph  ÿw8éí   ÷Gh   „™  3ÛSSjÿwXèŸ¿üÿé†  ‹ÏèEİÿÿ…À„w  ÷Gh  @ ‹j X•À‰Mø@Á‰Eüé®  ÷Gh   „M  ƒú„D  ‹G@ö@…7  3ÛSSh   ÿwXèê¿üÿ·À…À„  PÿwXè–÷üÿ‹ğ…ö„  jVj(ÿwXè¿¿üÿöGh…ñ  Sjh   VéSÿÿÿƒúuQj	éN  ÷Gh   „É  3Àƒúj ”ÀPj(ÿwXèx¿üÿé¯  ‹Êƒá‰Màt‹Ãë‹O ‹Gt‹ˆ‹Mà‰Eø‰öÂ„%ÿÿÿ‹Eì9Eè…Ï  ;Eä„Æ  ‹G‰Eü…É…¸  ‰Eø‹éøşÿÿƒè%„6  ƒè„À  ƒè„>  ƒè„®  ƒè„  ƒè…$  ÷Gh   …  ‹Â3Û+Ã„   ƒètƒèuC‹G;GtPSSh   ÿw8è®¾üÿë'‹G;Gs"9Gu‹W ‹ÏèCQûÿ‹W ‹Ot‹‘Á‰‰G‹UôöÂ…µ  ‹G;G„©  d¡   ‹ˆÜ  …ÉyÁ¸     rCQjZ‹Ïèş÷ÿÿé{  ‹G;Gsµ9Gu°‹Ï‹S9Ÿä   t
‰WèF  ë
è0  ‰‰G‰GëŸ‹Gh¹  ÁèƒàPSÿwDÿw@jZèîÏüÿé%  ƒútƒú…  ¸  ë¸  3ÛSSPéSıÿÿ‹;OsYöÂ‹Ñ‹Ït
VSSèï3ûÿëS9Ÿä   tèÆ  ëè°  ‰öEôt‹Uä9Uè…]şÿÿ9Uì„Tşÿÿ‹‰Eøéÿ   ‹‰Eøé?ıÿÿ‹G;G„•  öÂ…Œ  ‹Áëß‹G‹W H;Ât‹Ot‹;D‘u3ÛCë3Û3Ò‹ÏBèHYûÿ‹ğ‹ÏEÜ‹ÖPSÿwèùÿÿj‹Ö‹Ïèÿ[ûÿƒ}ğ&‹¤   u÷Ù‹Eà‹]ô@Á‰EàöÃ…   éüÿÿ9tPöÂ‹Ï‹tSVjè3ûÿëj9Ÿä   tèá  ëèË  ‰öEô„6ÿÿÿ‹Eì9Eè… ÿÿÿ;Eä„ÿÿÿéfıÿÿ‹G;G„»   öÂ…²   ‰]ø‰]ü3Ò‹ÏèŠXûÿÿuü‹Ğ‰Eàÿuø‹ÏèbBûÿ‹6‹Ï‹Öè¯Pûÿƒ}ğ#‰G ua‹Ot;4uY;wsT÷Gh @  tK…ÀtG‹ÏèKûÿ÷Gh  @ ‹ğ‹W ‹Ot‹‘t¹
  f9L0şë·OrƒÀş¯È<1 
 tBÿ‰G ‹ÏèœKûÿ‹Uà‹ÏèÅUûÿ‹Uà‹ÏSèÃZûÿ‹ÏèùYûÿ_^[ÉÂ ‹ÿU‹ìƒìS‰Uè3ÒVWB‹ùèÈWûÿ‹w‹È‹G‹Ñƒeì ‰EüEìPÿu‰Mğ‹Ïè6ûÿ‹U‹Ø‹Eè‹
‰O\‹J‰O`‹M‰Od-   „  ‹Uì‰Uìƒè„  ƒè„Ï   ƒè…+  ‹Gh¹ @ #Á;ÁuA‹Ïè–Jûÿ‹_‹ÏŠè„Zûÿ3Ò…Àu‹O ‹Gt;ˆ•ÂEø‹ÏPEôPR‹Óè:1ûÿ‹Ïè­Jûÿë‹Gt3É;EøPEô•ÁPQ‹Ó‹Ïè1ûÿöEu‹Mø‹Ù‹uô‰Oë3‹G‹Ï;GEøPEôPu‹uô‹]ü‹Ó‰wjë
‹]ø‹Ö‰_j èÑ0ûÿ‹Mø‹Eô‹Uì‰‡Ü   ‰à   ëZöGh„[  j`hşÿ  ÿw8ÿ¬*êijèÓmıÿ‹uğ‹Ï‹Öè:Tûÿƒghûé2  ‰]ø‰]ôöÁuK‹ó‰]ü‰_ƒ§à    ƒ§Ü    ‹]üÿw8ƒghû‰W ÿ$,êi¡(üéiƒOhÿ°p  hşÿ  ÿw8ÿĞ)êiéÂ   ‹G;Gu¯‹óë®öGh„Ã   ‹J…Éy÷Ùë+OT¡(üéiÁá‹€p  +Áƒø}3À@Phşÿ  ÿw8ÿĞ)êi‹‡Ü   …Àu$9‡à   u‹G;Gu;Gt‰_‹óëH‰_‰]üë@;Ã‹ÓEø‹ÏPöEôPF‹ÆƒğPè™/ûÿ…öt‹uô‹‡à   ‰w‰Eüë‹Mø‹·Ü   ‰Mü‰O‹Eì‹]ü‰G SV‹uğ‹Ï‹Öè)?ûÿ‹ÏèJWûÿë‹uğj‹Ö‹ÏèıWûÿöGhu}è  u	ÿw8ÿä+êi_^[ÉÂ ‹ÿU‹ìƒ} VW‹ò‹ùte…ö„î   Vèáÿÿ‹ğ…ö„Ş   ÷Gh  @ ‹ÏtèHûÿÆ¹
  f9Hÿuyƒîtt€xşë èıGûÿjpXf9Aşu]fƒ9
uWƒîtRf9AüuLNëI;wƒˆ   Vè-àÿÿ‹ğ;ws{÷Gh  @ ‹Ït1è·Gûÿ¹
  f9L0ÿuFë…ötf90u
€|0ÿuƒÆ‹ÏèÜGûÿë?Sè…Gûÿj
[jp·QşXf;Ğuf9uFë…ötf;Ğuf9u	f9YuƒÆ‹ÏèœGûÿ[_‹Æ^]Â ‹ÿU‹ìQQSVW‰Uü‹ù3öè.Gûÿ3Ò‰EøB‹Ïè×Sûÿ‹Ø…Ût+ÿu‹·ä   ÿuüÿuø‹v‹ÎSWÿT0êiÿÖj‹Ó‹Ï‹ğè{Vûÿ‹Ïè8Gûÿ_‹Æ^[ÉÂ ‹ÿU‹ìƒìSVWh@€  3ö‹ùVVjº  3Éèr“üÿPÿğ)êiÿw8‰Eøèòûÿ…À„Œ   ‹Ohá  @ ÷ÙÉƒáôƒÁQè¬Üûÿ‹Ø…ÛtgSÿì"êi= €  tY‹Ïè<AûÿSÿğ"êi‹Ğ…ÒtE÷Gh  @ ‹ÊtA‰EüŠA„Àuù+MüëA‰Eüf‹ƒÁf;Æuõ+MüÑùVQ‹Ïè>ûÿS‹ğÿä"êiÿÔ)êiÿuøÿğ)êi_‹Æ^[ÉÃÂ  ‹ÿU‹ì;QsV‹u‹At4B;Qrô^]Â ‹ÿU‹ìQQSVW‹}3À‹Ú‹ñ…ÿtj9F0t‹F4¯Çë]‰Eø‰Eü‹Fh%@  ƒø@u‹†    ¯Çë9èEûÿ÷Fh  @ ‹ĞEøP‹EWtÂPSÿH!êiëBPSÿ¤!êi‹Îè»Eûÿ‹Eø+†¨   _^[ÉÂ ‹ÿU‹ì‹E+A$…À3Àë	Pÿq$è\ÿÿÿ]Â ‹ÿU‹ìQQSVW‹ù‰Uü‹_$è%Eûÿ‹OP‹ğ+OH·GrjQ‹O¯Ã+ËQ‹ÏÆ‹uüP‹ÖèXÔÿÿ‹Ï‰EøèCEûÿ‹W$‹Eø;Os‹E+Â…À3ÀëQPR‹Ö‹ÏèêşÿÿëDPS‹Ö‹Ïèİşÿÿ‹wP+chAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map