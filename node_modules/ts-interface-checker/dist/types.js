"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */
// tslint:disable:no-shadowed-variable prefer-for-of
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = require("./util");
/** Node that represents a type. */
var TType = /** @class */ (function () {
    function TType() {
    }
    return TType;
}());
exports.TType = TType;
/** Parses a type spec into a TType node. */
function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) {
        throw new Error("Unknown type " + name);
    }
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */
function name(value) { return new TName(value); }
exports.name = name;
var TName = /** @class */ (function (_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) {
            return checker;
        }
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
    };
    return TName;
}(TType));
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */
function lit(value) { return new TLiteral(value); }
exports.lit = lit;
var TLiteral = /** @class */ (function (_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TLiteral;
}(TType));
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */
function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
exports.array = array;
var TArray = /** @class */ (function (_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function (suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < value.length; i++) {
                var ok = itemChecker(value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
    };
    return TArray;
}(TType));
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */
function tuple() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.tuple = tuple;
var TTuple = /** @class */ (function (_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function (suite, strict) {
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType));
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */
function union() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.union = union;
var TUnion = /** @class */ (function (_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
            .filter(function (n) { return n; });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) {
                names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
        }
        else {
            _this._failMsg = "is none of " + otherTypes + " types";
        }
        return _this;
    }
    TUnion.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        return function (value, ctx) {
            var ur = ctx.unionResolver();
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) {
                    return true;
                }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType));
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */
function intersection() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.intersection = intersection;
var TIntersection = /** @class */ (function (_super) {
    __extends(TIntersection, _super);
    function TIntersection(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TIntersection.prototype.getChecker = function (suite, strict) {
        var allowedProps = new Set();
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });
        return function (value, ctx) {
            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });
            if (ok) {
                return true;
            }
            return ctx.fail(null, null, 0);
        };
    };
    return TIntersection;
}(TType));
exports.TIntersection = TIntersection;
/**
 * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).
 */
function enumtype(values) {
    return new TEnumType(values);
}
exports.enumtype = enumtype;
var TEnumType = /** @class */ (function (_super) {
    __extends(TEnumType, _super);
    function TEnumType(members) {
        var _this = _super.call(this) || this;
        _this.members = members;
        _this.validValues = new Set();
        _this._failMsg = "is not a valid enum value";
        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));
        return _this;
    }
    TEnumType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) {
            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));
        };
    };
    return TEnumType;
}(TType));
exports.TEnumType = TEnumType;
/**
 * Defines a literal enum value, such as Direction.Up, specified as enumlit("Direction", "Up").
 */
function enumlit(name, prop) {
    return new TEnumLiteral(name, prop);
}
exports.enumlit = enumlit;
var TEnumLiteral = /** @class */ (function (_super) {
    __extends(TEnumLiteral, _super);
    function TEnumLiteral(enumName, prop) {
        var _this = _super.call(this) || this;
        _this.enumName = enumName;
        _this.prop = prop;
        _this._failMsg = "is not " + enumName + "." + prop;
        return _this;
    }
    TEnumLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var ttype = getNamedType(suite, this.enumName);
        if (!(ttype instanceof TEnumType)) {
            throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        }
        var val = ttype.members[this.prop];
        if (!ttype.members.hasOwnProperty(this.prop)) {
            throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        }
        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TEnumLiteral;
}(TType));
exports.TEnumLiteral = TEnumLiteral;
function makeIfaceProps(props) {
    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });
}
function makeIfaceProp(name, prop) {
    return prop instanceof TOptional ?
        new TProp(name, prop.ttype, true) :
        new TProp(name, parseSpec(prop), false);
}
/**
 * Defines an interface. The first argument is an array of interfaces that it extends, and the
 * second is an array of properties.
 */
function iface(bases, props) {
    return new TIface(bases, makeIfaceProps(props));
}
exports.iface = iface;
var TIface = /** @class */ (function (_super) {
    __extends(TIface, _super);
    function TIface(bases, props) {
        var _this = _super.call(this) || this;
        _this.bases = bases;
        _this.props = props;
        _this.propSet = new Set(props.map(function (p) { return p.name; }));
        return _this;
    }
    TIface.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });
        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        // Consider a prop required if it's not optiÈÿğÁƒøu
3ÒH‹ËèëaóÿL‹„$   I‹ÔH‹ÎI‹ÅÿúÿHÿEúÿD  3ÒH‹ÍHÿ,úÿD  H‹ŞH‹?éüÿƒÈÿğÁƒø…3üÿ3ÒH‹Ëè’aóÿé#üÿ¹!   Hƒ÷ÿè—›úÿéüÿÌ¹2   Hğ‚÷ÿL‹ÃèàŸúÿéAüÿ¹3   HÖ‚÷ÿL‹ËL‹Çè/úÿé=üÿ¹4   H¹‚÷ÿèH›úÿéIüÿ¹'   H
Ê÷ÿL‹Ãè’ŸúÿéaüÿH‹K0èw"üÿé“üÿ¹(   HáÉ÷ÿè›úÿéÍüÿ¹7   HÊÉ÷ÿL‹ÃèRŸúÿéğüÿH‹ÏèÄª ƒÈÿğÁƒø…üÿH‹Ïè "üÿéüÿ¹=   HŠÉ÷ÿL‹ÃèŸúÿé üÿ¹>   HpÉ÷ÿè—šúÿéüÿH‹ËèQüÿéüÿ¹8   HKÉ÷ÿèršúÿéüÿ¹   Í)Ì¹   H,É÷ÿL‹Ãè´úÿé+üÿH‹KH“€   H‹I8è&ÖôÿéüÿH‹Kè/üÿéIüÿ¹   HéÈ÷ÿèšúÿéXüÿH‹IH…ÉtƒÈÿğÁƒøu	H‹KèŒ1 ƒ#şé[üÿD‹ÇH‹Íèyò é¿üÿÌL‹KH«È÷ÿ¹   L‹ÃèŠ›úÿé!üÿHƒ£   HÿúÿD  3ÒHx  HÿÌúÿD  HGL‹ I9@u`H‹PH9uWL‰Hx  I‰P3ÒHƒ  Hƒ` H‹C0ÿHXHÿ‚úÿD  Hÿ†úÿD  ƒÈÿğÁGƒø…¢üÿH‹Ïèdd é”üÿ¹   Í)¹   HïÇ÷ÿè™úÿé†üÿH…ÛtL‹IëE3É¹    HÊ¡÷ÿL‹Ãè®šúÿé•üÿ¹!   H°¡÷ÿL‹Ãè(úÿé‰üÿHH …ÿxèEüÿ‹øéyüÿè9üÿénüÿ¹"   Hw¡÷ÿD‹Çèã™úÿénüÿÌL‹KHM¡÷ÿ¹,   L‹Ãè<šúÿéüÿ¹-   H.¡÷ÿèU˜úÿé¯üÿÌ¹   H&¡÷ÿL‹ÃèœúÿéÈüÿH‹8H‹ĞH‹ËHÿXúÿD  ƒÈÿğÁƒø…ÁüÿH‹Ïè_üÿé³üÿ¹   HÙ ÷ÿèğ—úÿéâüÿ¹Z   L‰t$(L‹ËD‰|$ M‹ÄH:÷ÿèM±úÿéüÿH9X…ä   H‹H9A…×   H‰H¸ùÿÿH‰YHƒ  Hƒ` H‹w÷ùÿ    t¹[   Hå~÷ÿL‹ÇèÕ›úÿHÿÆúÿD  H®Ğ  3ÒH‹ÍHÿúÿD  ‹†  ¨u2L‰t$0HÛÃ÷ÿÇD$(   E3ÉM‹ÄH‰D$ A‹×H‹Ïè•ôÿH‹Îè	”ôÿ3ÒH‹ÍHÿ9úÿD  Hÿ=úÿD  ƒÈÿğÁG0ƒø…#üÿH‹Ïè÷±òÿéüÿ¹   Í)¹\   H.~÷ÿè½–úÿéüÿÌ¹   H~÷ÿD‹Ãèú—úÿé.üÿƒût
»   é<üÿ»   é2üÿ¹€   Hã}÷ÿD‹ÃèÇ—úÿé(üÿÌ¹)   H0Ÿ÷ÿL‹Ãè¸šúÿéKüÿ¹*   HŸ÷ÿL‹ÃèšúÿH‹‹8  éKüÿ¹+   Hö÷ÿè–úÿé`üÿÌ¹&   HŞ÷ÿL‹Ãèfšúÿé|üÿ¹'   HÄ÷ÿL‹ÃèLšúÿé{üÿ¹(   Hª÷ÿèÑ•úÿé“üÿÌ¹.   Hz£÷ÿL‹ÏL‹Æèƒ—úÿé.üÿA¼0   A·éNüÿ÷!ùÿ   „èüÿ¹/   ë¹3   D‹ÀH5£÷ÿèÌ–úÿéÇüÿH‹L$0H|$`‹‰D$`H‹AH‰D$hH‹AH‰D$p‹A‰D$x‹AH‰E€·A f‰Eˆ·A"f‰EŠ‹A$H‰E‹A(‰E˜éùüÿH‹WH‹L$8èÎ( ‹Ø…À‰]üÿ÷†ùÿ   „MüÿL‹GH¥¢÷ÿ¹0   D‹Èè0˜úÿé/üÿ÷Xùÿ   „üÿ¹1   é9ÿÿÿ÷>ùÿ   t$¹2   H`¢÷ÿèŸ”úÿë¹4   HM¢÷ÿèä•úÿ»  ÀéÛüÿ÷ùÿ   têë×A½   L‹ùÿE‹ÅHU@HM Hÿ‘úÿD  ‹Ø…Ày÷Ìùÿ   „“üÿé­şÿÿLu éQüÿ÷®ùÿ   „lüÿD‹ÈLD$@èûÿéYüÿI‹ÎHÿCúÿD  éMüÿ¹6   H¤¡÷ÿD‹Ãè8•úÿéMüÿ¾…˜   ¹x   ‰D$8M‹Ì‹…   M‹Æ‰D$0I‹GL‰l$(H‰D$ è_âúÿé²üÿM‹G¹y   L‹Îè”Ûúÿé®üÿ‹ùÿ¨tM‹GHYœ÷ÿ¹z   D‹ËèüÚúÿE3ÿéüÿ»  ÀéŞüÿ‹Üùÿ¨„Ğüÿ¹{   H œ÷ÿD‹ÃèŒ”úÿé¶üÿ‹´ùÿöÁt¹}   Hû›÷ÿè“úÿ»Z  ÀézüÿH‹D$h¹~   L‹ÎH‰D$ D‹ÃèbÛúÿé(üÿ‹nùÿ¨„Lüÿ¹   H²›÷ÿD‹Ãè”úÿé2üÿL9yx„(üÿè‘Üôÿéüÿ‹1ùÿ¨t¹|   Hy›÷ÿL‹Æèñ–úÿ»  ÀéõüÿŠ…˜   HT$`D‹   M‹ÅI‹N8Dˆ|$(ˆD$ è˜ ‹Ø…À‰Úüÿ‹Øùÿ¨„ÌüÿL‹D$hH›÷ÿ¹€   D‹Ëè¿Ùúÿé—üÿH‹ÏèİçñÿéŸüÿ¹   Hïš÷ÿD‹Ãè[“úÿéÓüÿÌH‹B¹#   HÀš÷ÿH‰D$ L‹ËL‹Æèd£úÿéüÿ¹$   Hš÷ÿèÅ‘úÿé;üÿÌ¹   H–š÷ÿL‹Ãè–úÿéUüÿH‹Ëèpš é]üÿH‹ËèD ‹øé¦üÿ¹   H_š÷ÿD‹ÇèË’úÿé›üÿÌH9Bu)H9B u#ƒL$(ÿL(îñÿHƒL$ ÿA±3ÉèÌñÿHƒÄ0[ÃÌA¹ı  L¼Ÿ÷ÿ¹   èÆYóÿÌÌ¹K   H‰|$ L‹ËHô™÷ÿL‹Æè¢úÿé§üÿHƒ' »4  ÀéíüÿL‹HÎ™÷ÿ¹L   D‹Ëè1”úÿéŞüÿÌ¹   L‹ËH‹Öè–’úÿéüÿ¹   H‹Öè•úÿL‹G0é›üÿ¹   H‹Öè•úÿL‹G0éüÿH=XCSeu,÷ùÿ   t¹   H‹Öè×”úÿL‹G0I‹Hèv¶ éìüÿ÷Şùÿ   „Üüÿ¹   H‹Öè§”úÿéÉüÿHZùÿè%€ ééüÿ¹   E3ÀH‹Öès‘úÿéãüÿÌ¹   HÜ¾÷ÿL‹Çèd”úÿé0üÿ¹;   HÂ¾÷ÿL‹ÇèJ”úÿéTüÿHKàH‹è´üÿéIüÿ¹<   H–¾÷ÿè½úÿéHüÿ¹   H¾÷ÿè¦úÿéˆüÿ¹   Hh¾÷ÿL‹Ãèğ“úÿé§üÿ¹   HN¾÷ÿèuúÿéÉüÿÌ¹1   H6¾÷ÿL‹Ãè¾“úÿéÕüÿ¹2   H¾÷ÿèCúÿéCüÿÌ¹x   Hœv÷ÿL‹ÃèŒ“úÿé]üÿ¹y   H‚v÷ÿèúÿé{üÿÌ¹0   Hjv÷ÿL‹ÃèZ“úÿé‡üÿ¹1   HPv÷ÿèßúÿé$üÿÌ¹v   H8v÷ÿL‹Ãè(“úÿé-üÿ¹w   Hv÷ÿè­úÿé§üÿÌHD$PL‹ÃH‰D$(LL$`HD$XH‰D$ è™úÿé¶üÿ÷ùÿ   t¹   H£–÷ÿèbúÿ@2ÿéáüÿ÷Ü
ùÿ   tì¹   H~–÷ÿè=úÿ@2ÿé¼üÿ‹D$PD‹L$`‰D$(‹D$XD¶Ç‰D$ è‹úÿé¨üÿÌ¹   Hpœ÷ÿD‹ÅèTúÿéüÿG‹çHWœ÷ÿ¹   D‹Æèjúÿééüÿ¾„$P  ¹   ‰D$@H‰T$8D‰l$0L‰L$(‰\$ M‹ÏM‹ÆèaşúÿL‹L$Xé¯üÿ»  Àë»#  ÀL‹l$XDŠöéG³üÿ¹   HD$hH‰D$ DIõM‹ÆH%›÷ÿèÌ˜úÿé¯üÿ»»  Àé°üÿ»d Àéø¯üÿ»  Àéî¯üÿ»  Àéä¯üÿ¹   D‹ËL‹D$hHŞš÷ÿèqúÿéÒ¯üÿ»  ÀëDŠöL‹l$XéÄ²üÿ¹
   L‹ËL‹„$   HH•÷ÿè·úÿéW±üÿH…ötL‹H@ëL‹Ï¹   L‹ÆH •÷ÿèúÿéT±üÿ»: Àë¥»„ ÀL‹l$Xé_²üÿ¹·   L‹N@L‹ÆH<š÷ÿè[úÿéx±üÿ» Àéµ±üÿ‹à  ƒù•ÃÃ  Àé±üÿ¹¸   D‹ÃHš÷ÿè¨úÿé‘±üÿƒ¾à  
„É±üÿE;õƒÃ±üÿ»»  Àë€…Àu
»»  ÀéÛ±üÿE…äaram = TParam;
/**
 * Defines a function parameter list.
 */
var TParamList = /** @class */ (function (_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function (param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) {
                        return ctx.fail(p.name, "is missing", 1);
                    }
                }
                else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) {
                        return ctx.fail(p.name, null, 1);
                    }
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType));
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */
var BasicType = /** @class */ (function (_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
    };
    return BasicType;
}(TType));
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */
exports.basicTypes = {
    any: new BasicType(function (v) { return true; }, "is invalid"),
    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
    void: new BasicType(function (v) { return (v == null); }, "is not void"),
    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
    null: new BasicType(function (v) { return (v === null); }, "is not null"),
    never: new BasicType(function (v) { return false; }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
}
if (typeof Buffer !== "undefined") {
    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
}
var _loop_1 = function (array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
    var array_1 = _a[_i];
    _loop_1(array_1);
}
