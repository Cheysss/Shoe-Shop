"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');

var _getClassInfo = require('../util/getClassInfo'); var _getClassInfo2 = _interopRequireDefault(_getClassInfo);
var _CJSImportTransformer = require('./CJSImportTransformer'); var _CJSImportTransformer2 = _interopRequireDefault(_CJSImportTransformer);
var _ESMImportTransformer = require('./ESMImportTransformer'); var _ESMImportTransformer2 = _interopRequireDefault(_ESMImportTransformer);
var _FlowTransformer = require('./FlowTransformer'); var _FlowTransformer2 = _interopRequireDefault(_FlowTransformer);
var _JestHoistTransformer = require('./JestHoistTransformer'); var _JestHoistTransformer2 = _interopRequireDefault(_JestHoistTransformer);
var _JSXTransformer = require('./JSXTransformer'); var _JSXTransformer2 = _interopRequireDefault(_JSXTransformer);
var _NumericSeparatorTransformer = require('./NumericSeparatorTransformer'); var _NumericSeparatorTransformer2 = _interopRequireDefault(_NumericSeparatorTransformer);
var _OptionalCatchBindingTransformer = require('./OptionalCatchBindingTransformer'); var _OptionalCatchBindingTransformer2 = _interopRequireDefault(_OptionalCatchBindingTransformer);
var _OptionalChainingNullishTransformer = require('./OptionalChainingNullishTransformer'); var _OptionalChainingNullishTransformer2 = _interopRequireDefault(_OptionalChainingNullishTransformer);
var _ReactDisplayNameTransformer = require('./ReactDisplayNameTransformer'); var _ReactDisplayNameTransformer2 = _interopRequireDefault(_ReactDisplayNameTransformer);
var _ReactHotLoaderTransformer = require('./ReactHotLoaderTransformer'); var _ReactHotLoaderTransformer2 = _interopRequireDefault(_ReactHotLoaderTransformer);

var _TypeScriptTransformer = require('./TypeScriptTransformer'); var _TypeScriptTransformer2 = _interopRequireDefault(_TypeScriptTransformer);








 class RootTransformer {
   __init() {this.transformers = []}
  
  
   __init2() {this.generatedVariables = []}
  
  
  
  

  constructor(
    sucraseContext,
    transforms,
    enableLegacyBabel5ModuleInterop,
    options,
  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const {tokenProcessor, importProcessor} = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);

    if (!options.disableESTransforms) {
      this.transformers.push(
        new (0, _OptionalChainingNullishTransformer2.default)(tokenProcessor, this.nameManager),
      );
      this.transformers.push(new (0, _NumericSeparatorTransformer2.default)(tokenProcessor));
      this.transformers.push(new (0, _OptionalCatchBindingTransformer2.default)(tokenProcessor, this.nameManager));
    }

    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(
          new (0, _JSXTransformer2.default)(this, tokenProcessor, importProcessor, this.nameManager, options),
        );
      }
      this.transformers.push(
        new (0, _ReactDisplayNameTransformer2.default)(this, tokenProcessor, importProcessor, options),
      );
    }

    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new (0, _ReactHotLoaderTransformer2.default)(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }

    // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new (0, _CJSImportTransformer2.default)(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.preserveDynamicImport),
          Boolean(options.keepUnusedImports),
        ),
      );
    } else {
      this.transformers.push(
        new (0, _ESMImportTransformer2.default)(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.keepUnusedImports),
          options,
        ),
      );
    }

    if (transforms.includes("flow")) {
      this.transformers.push(
        new (0, _FlowTransformer2.default)(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new (0, _TypeScriptTransformer2.default)(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new (0, _JestHoistTransformer2.default)(this, tokenProcessor, this.nameManager, importProcessor),
      );
    }
  }

  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    // "use strict" always needs to be first, so override the normal transformer order.
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map((v) => ` var ${v};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result = this.tokens.finish();
    let {code} = result;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    } else {
      return {
        code: prefix + code + suffix,
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    }
  }

  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(_types.TokenType.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(_types.TokenType.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(_types.TokenType.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }

  processToken() {
    if (this.tokens.matches1(_types.TokenType._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }

  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(_types.TokenType._class, _types.TokenType.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }

  processClass() {
    const classInfo = _getClassInfo2.default.call(void 0, this, this.tokens, this.nameManager, this.disableESTransforms);

    // Both static and instance initializers need a class name to use to invoke the initializer, so
    // assign to one if necessary.
    const needsCommaExpression =
      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&
      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;

    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }

    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context ID.");
    }
    this.tokens.copyExpectedToken(_types.TokenType._class);
    while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
      this.processToken();
    }

    this.processClassBody(classInfo, className);

    const staticInitializerStatements = classInfo.staticInitializerNames.map(
      (name) => `${className}.${name}()`,
    );
    if (needsCommaExpression) {
      this.tokens.appendCode(
        `, ${staticInitializerStatements.map((s) => `${s}, `).join("")}${className})`,
      );
    } else if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(" ")}`);
    }
  }

  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove,
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(_types.TokenType.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode(
        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}",
      );
    }

    const needsConstructorInit =
      constructorInitializerStatements.length + instanceInitializerNames.length > 0;

    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(
        constructorInitializerStatements,
        instanceInitializerNames,
        className,
      );
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,
        );
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }

    while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(_types.TokenType.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[   M e n u F l y o u t I t e m W i t h N e w B a d g e S t y l e      T o g g l e M e n u F l y o u t I t e m S t y l e                          "       ¥                        !          ≥                          #       ì   ì   ™  ™  Ù  Ù  Å  Å  @  @  n  n  R  R      -  -  /  /  a  a  »;  »;  <  <  À<  À<  ¶=  ¶=  Ê=  Ê=  #@  #@  2D  2D  zD  zD  XG  XG  qN  qN  ØN  ØN  ÏP  ÏP  ˚T  ˚T  -U  -U  ’U  ’U  V  V  
X  
X  3Z  3Z  oZ  oZ  —\  —\  ˙^  ˙^  2_  2_  .a  .a  Wc            x     c o m m a n d s  	   c o n v e r t e r     l o c a l sÅ  
- Tx ÀÕ ı§   ]7 aŒ ˙ä úœ £– û— Ò“ ƒx ä §     !          x     c o m m a n d s  	   c o n v e r t e r     l o c a l sÅ4Ä  @B!  !rÄ˜ÄÇ  ÇÇ0Ç                0/á                #Ç$Ç0'Ç  (Ç0äÅp   0)Çp   0-Ç          A    0Ç0XÜ0òÅ¨   01Ç¨    ôÅC!rÄ˜Ä   	Ç0¯ÉA    (Ç0äÅp   0)Çp    0+Ç0Ç0òÅ¨    01Ç¨    !rÄx ˜Ä-Ç  0ˆÜÇÇ#Ç0'Ç (Ç0äÅp    0Ç0XÜ0òÅ¨    0ëÅ  @B!rÄä ˜Ä-Ç  0ˆÜÇÇ#Ç0'Ç (Ç0äÅp    0ëÅ  àB0Ç0XÜ0òÅ¨    0ôÅ  ¿ˇ!rÄ˜Ä-Ç  0ˆÜÇÇ#Ç0'Ç (Ç0äÅp    0ëÅ  òB0Ç0XÜ0òÅ¨    0ôÅ  ¿ˇ!rÄ§ ˜Ä-Ç  0ˆÜÇÇ#Ç0'Ç (Ç0äÅp    0ëÅ  àB0Ç0XÜ0òÅ¨    0ôÅ  ¿ˇ!rÄ˜Ä
Ç  0Ä≤ ÇÇÇèÅêÅ0-Ç       A       A0±Ñé    0≤Ñí    0∂Ñ0πÑ0≈Ñé   0∆Ñí   0ÃÑ≥    0Ç!rÄ˜Ä   	Ç$Ç(Ç0)Çp   0êÅ  8B0-Ç                0Ç0XÜ01Ç¨   !rÄ˜Ä   	Ç$Ç(Ç0)Çp   0êÅ  8B0-Ç                0Ç0XÜ01Ç¨   !rÄ˜Ä*Ç   	Ç$Ç(Ç0)Çp   0êÅ  8B0-Ç                0Ç0XÜ01Ç¨   !$€Å $€Å	 $€Å
 $€Å $€Å øÄgÅÇuÄ 	         !€Å$€Å ∫ÅàÇ(Å Ä<    îÜ-ÇßÜ)Ç®Ü1ÇêÜÇëÜÇíÜÇÇAÉÇCÉ!FÅ                   ™      ∂              !FÅäÄ CÅâÄ !âÄ âÅÉÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!!BÅ!âÄ âÅÉÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!!BÅ!âÄ âÅÉÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!ÄÉ É ÆÅ≈Ä∑Ä    $∏Ä !!!BÅ!!$€Å# $€Å$ øÄgÅ uÄ7 - : ; I J a !€Å∫Å% îÅ  
' ( n     Å4ÇÌÅ) Å◊Åã   ! ÓÅ! ÷ÅùÅ* 4ÇÌÅ+ Å◊Åã   ! ÓÅ! /É!wÄ!'ÅàÇ∫Å, âÅâÅ$êÅ- çÅ-ÇòÅ¨    áÇÇZÉ,Ä_Ä     Ä?!,Ä_Ä      Ä?!ùÅ. !3ÅàÇ∫ÅZÉ,Ä/ _Ä     Ä?!,Ä0 _Ä      Ä?!,Ä1 _Ä     Ä?!àÇ≥Å2 äÅ)ÇòÅ1Ç)Ç)Ç1Ç1Ç@É@ÉAÉAÉCÉCÉ(Ç(Ç+Ç!≥Å3 YÉ   çÅ                äÅ)ÇòÅ1Ç)Ç)Ç1Ç1ÇÅ·Å4 ! @ÉAÉAÉCÉCÉ(Ç(Ç+Ç!√Å5 YÉ   $êÅ- çÅ                äÅp   +Ç„ÄuÄ  !yÉ!!Ç6 YÉ   $êÅ- -Ç  ÄA  ∏A  ÄA    òÅ¨    (Ç(ÇïÅ7 4ÇÌÅ8 Å◊Åã   ! ÓÅ! 8Å∏Å9 $âÅ: òÅ¨   $SÉ; TÉ  ÄAWÉ< !@É!kÅ= ùÅ> !3Å∫Å? 4ÇÌÅ@ Å◊Åã   ! ÓÅ! ëÅ4ÇÌÅA Å◊Åã   ! ÓÅ! èÅ4ÇÌÅB Å◊Åã   ! ÓÅ! éÅÅC !'ÅùÅD 4ÇÌÅE Å◊Åã   ! ÓÅ! .É!3ÅàÇÉF *Ç+ÇïÅ∏ÜrÄ˜Ä÷Ä	  0äÅp   0ôÅ  ¿ˇ!tÉùÅG !3Å!!úÇ!ÍÇ
  	H  !!FÅ                L      M ∫D     Z ÜG     ] ºI     ^ ÍL     c ‹P     d ¯S     e ƒU     g –X     l      m ú[     o ÿ[     q      r ≠\æ\œ\     K Vk Ç[p ê\M L `L M ¨Z L ‡	L Z Â^ ] ∆] ^ Çc ] é"] c √)e d º0d e »5g d º:d g √? 			


    K L M Z ] ^ c d e g k l m o p q r !îÅâÅÉ…ÄÉ& qÅƒÄkÄ    lÄ    !ÅﬁÅ	   0 . 1 , 0 . 9   0 . 2 , 1 . 0 kÄ†Ô>lÄ  Ä?!!!
' âÅÉ…ÄÉ& qÅƒÄkÄ    lÄ  Ä?!ÅﬁÅ		   0 . 2 , 0   0 , 1 kÄ+>lÄ    !!!
( ·Å¬ÉÅ   !÷ÅH [É   òÅ¨   $‡ÇI ËÇ  Ä?8Å∞   !FÅäÄ CÅâÄ !âÄ âÅÉÄÉ9 É ÆÅ≈Ä∑Ä    $∏ÄJ !!!BÅ!!äÄK DÅåÄGÅL HÅ		   0 : 0 : 0 . 4 6 7 KÅM âÅÉÄÉ6 ÉN ÆÅ≈Ä∑Ä    ∏ÄO !!ÄÉH ÉP ÆÅ≈Ä∑Ä    ∏ÄQ !!ÄÉC ÉR ÆÅ≈Ä∑Ä    4ÇÌÅS Å◊Åã   ! ÓÅ! ∏Ä!!…ÄÉD ÉT qÅƒÄkÄ    4ÇÌÅU Å◊Åã   ! ÓÅ! lÄ!!ÄÉF ÉV ÆÅ≈Ä∑Ä    ∏ÄW !!ÄÉ> ÉT ÆÅ≈Ä∑Ä    ∏ÄX !!…ÄÉ. ÉT qÅƒÄkÄ    lÄ    !ÅﬁÅ	   0 . 1 , 0 . 9   0 . 2 , 1 . 0 kÄ†Ô>4ÇÌÅ+ Å◊Åã   ! ÓÅ! lÄ!!…ÄÉG ÉT qÅƒÄkÄ    4ÇÌÅY Å◊Åã   ! ÓÅ! lÄ!ÅﬁÅ	   0 . 1 , 0 . 9   0 . 2 , 1 . 0 kÄ†Ô>lÄ    !!!JÅ!åÄGÅM HÅ		   0 : 0 : 0 . 1 6 7 KÅL âÅÉÄÉ6 ÉN ÆÅ≈Ä∑Ä    ∏ÄO !!ÄÉH ÉP ÆÅ≈Ä∑Ä    ∏ÄQ !!ÄÉC ÉR ÆÅ≈Ä∑Ä    4ÇÌÅS Å◊Åã   ! ÓÅ! ∏Ä!!…ÄÉD ÉT qÅƒÄkÄ    4ÇÌÅU Å◊Åã   ! ÓÅ! lÄ!!ÄÉF ÉV ÆÅ≈Ä∑Ä    ∏ÄW !!ÄÉ> ÉT ÆÅ≈Ä∑Ä    ∏ÄX !!…ÄÉ. ÉT qÅƒÄkÄ    4ÇÌÅ+ Å◊Åã   ! ÓÅ! lÄ!ÅﬁÅ		   