


import {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from "../parser/tokenizer";
import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";


import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
   __init() {this.hadExport = false}
   __init2() {this.hadNamedExport = false}
   __init3() {this.hadDefaultExport = false}
  

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     enableLegacyBabel5ModuleInterop,
     enableLegacyTypeScriptModuleInterop,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     preserveDynamicImport,
     keepUnusedImports,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;
    this.declarationInfo = isTypeScriptTransformEnabled
      ? getDeclarationInfo(tokens)
      : EMPTY_DECLARATION_INFO;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }

  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(tt._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(tt.name, tt.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(tt.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(tt.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(tt.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop
        ? ""
        : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }

    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(tt.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
   removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }

    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {
      // We have a default import or namespace import, so there must be some
      // non-type import.
      this.removeRemainingImport();
      return false;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      return false;
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(tt.string)) {
      // Check if any named imports are of the form "foo" or "foo as bar", with
      // no leading "type".
      if (
        (!foundNonTypeImport && this.tokens.matches1(tt.braceL)) ||
        this.tokens.matches1(tt.comma)
      ) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(tt.braceR)) {
          foundAnyNamedImport = true;
        }
        if (
          this.tokens.matches2(tt.name, tt.comma) ||
          this.tokens.matches2(tt.name, tt.braceR) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)
        ) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   removeRemainingImport() {
    while (!this.tokens.matches1(tt.string)) {
      this.tokens.removeToken();
    }
  }

   processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }

    if (token.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }

    if (token.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token),
    );
    if (!replacement) {
      return false;
    }
    // Tolerate any number of closing parens while looking for an opening paren
    // that indicates a function call.
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (
      possibleOpenParenIndex < this.tokens.tokens.length &&
      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR
    ) {
      possibleOpenParenIndex++;
    }
    // Avoid treating imported functions as methods of their `exports` object
    // by using `(0, f)` when the identifier is in a paren expression. Else
    // use `Function.prototype.call` when the identifier is a guaranteed
    // function call. When using `call`, pass undefined as the context.
    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {
      if (
        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&
        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new
      ) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        // Remove the old paren.
        this.tokens.removeToken();
        // Balance out the new paren.
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(tt.parenR);
      } else {
        // See here: http://2ality.com/2015/12/references.html
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }

  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }

  processExport() {
    if (
      this.tokens.matches2(tt._export, tt._enum) ||
      this.tokens.matches3(tt._export, tt._const, tt._enum)
    ) {
      this.hadNamedExport = true;
      // Let the TypeScript transform handle it.
      return false;
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
        this.hadDefaultExport = true;
        // Flow export default enums need some special handling, so handle them
        // in that tranform rather than this one.
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.braceL)) {
      this.processExportBindings();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
  ë‹hà4@ èù7  Pÿl¢B YY…Àt¸  ‰Eä‹‹Mäë€zp ¹  uAr83Ò}ì¥¥¥¥uì¿Ü@ ‹–;—uBƒúuòÉ€   ‰K@‹Mü_^3Í[è2r  ÉÂ hd  ¸WB èó€  ‹Ù‹3ö‰C3À‰uèÇEì   f‰EØEØ‰uüPè[D  ‰µ´ıÿÿ´ıÿÿÆEüèC¬ÿÿƒ}ìMØr‹MØPh  VQh  €ÿ|¡B ‹ğƒştk…ö…†   ¸ıÿÿè¯çÿÿÆEü‹…Äıÿÿ‰…Àıÿÿë,EÈPèÎèÿÿ‹C9Ct‹øuÈ¥¥¥¥ƒCëMÈQP‹Ëè0%  ¸ıÿÿè™Q  ¸ıÿÿ…Àt¿èv©ÿÿƒ½´ıÿÿ tÿµ´ıÿÿÿx¡B MØèCªşÿè°  Ã¡ B = B t ö@t€xrVÿpº°?@ ÿpjYèE•şÿh(  h<=@ Vıÿÿèn—şÿhLˆB …ıÿÿPè  Ìh|  ¸ZWB è¢  QMØèå«şÿƒeü EØƒì‹ÌPèµ´şÿM„è»»ÿÿQQ‹ÄÆEü|şÿÿƒ  ƒ` E„Pè3  |şÿÿÆEüèu   |şÿÿè   M„èÿÿMØèo©şÿèÜ~  Ã‹ÿVW‹ù·¸   NèU©şÿ‹ÎèN©şÿ   èC©şÿOxè;©şÿOHèğÈÿÿÇÜ@ _^Ã‹ÿV‹ñNè©şÿ‹Î^é©şÿhH  ¸õWB èÎ~  ‹ù‰½4ÿÿÿ3À‹È‰…(ÿÿÿ‰<ÿÿÿ‰,ÿÿÿ8‡ø   t²‹Ïè·  é$  ‰…@ÿÿÿ‰Eü‰…0ÿÿÿjZ3É‰Eè‰Uìf‰MØ‰EĞ3À‰UÔf‰EÀ‡¸   ÆEüƒx‹Èr‹EØPQèBR  EÀ‹ÏPèÚ4  Pè¥A  €r …h  @ÿÿÿè¶©ÿÿƒ}ìMØr‹MØPh  3öVQh  €ÿ|¡B ‰…4ÿÿÿ…Àtƒø…ˆ  é€   0ÿÿÿèr©ÿÿƒ}ÔMÀr‹MÀPh  VQh  €ÿ|¡B ‰…4ÿÿÿ…ÀtuƒøtG‹ B ú B „z  öB„p  €z‚f  MÀèÿ©şÿPÿµ4ÿÿÿÿrÿrº°?@ jé9  ‡¸   ƒx·è   r‹ ƒì‹È‹ü¥¥¥¥èñ  éš  ‹@ÿÿÿ…(ÿÿÿPº7@ èD  „Àt¼‹0ÿÿÿ…,ÿÿÿPº7@ èúC  „Àt¡‹…(ÿÿÿ;…,ÿÿÿt“j‰…4ÿÿÿ…4ÿÿÿPjVh7@ ÿµ0ÿÿÿÿ`¡B …À„hÿÿÿ‹Èè:I  é\ÿÿÿ…¬şÿÿ‰½8ÿÿÿP8ÿÿÿèöùÿÿ‹‡   w8½\ÿÿÿ‰…<ÿÿÿ¥@ÿÿÿ¥¥¥è¨ÿÿƒ}ìMØr‹MØ•$ÿÿÿRP3ÀPh  PPPQh  €ÿt¡B ‹ğ…öt[ƒşu‹4ÿÿÿÁ   è,B  „À…”  ‹ B ú B t)öBt#€zrMØè•¨şÿPVÿrÿrº°?@ jYèI²ÿÿVéÚ  j…8ÿÿÿÇ…8ÿÿÿ   Pj3öVhh=@ ÿµ@ÿÿÿÿ`¡B …Àt‹Èè9H  ‹…Üşÿÿj‰…8ÿÿÿ…8ÿÿÿPjVhÈ7@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèH  ‹…àşÿÿj‰…8ÿÿÿ…8ÿÿÿPjVht=@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèÑG  ‹…äşÿÿj‰…8ÿÿÿ…8ÿÿÿPjVh”=@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèG  ‹…ğşÿÿj‰…8ÿÿÿ…8ÿÿÿPjVh´=@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèiG  ‹<ÿÿÿèGA  „À„  ‹…èşÿÿj‰…<ÿÿÿ…<ÿÿÿPjVhÌ=@ ÿµ@ÿÿÿÿ`¡B …Àt‹Èè"G  ‹½4ÿÿÿGHƒxr‹ PM„èî¦şÿÆEüE„ƒ}˜r‹E„PM¨èÕ¦şÿE¨ÆEü‹@ÿÿÿºä=@ Pè›G  M¨ÆEüè¤şÿ‹G‹O ‰8ÿÿÿƒøvbj‰…<ÿÿÿ…<ÿÿÿPjVhÀ"@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèŒF  ‹…8ÿÿÿj‰…<ÿÿÿ…<ÿÿÿPjVh7@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèXF  M„è"¤şÿë‹½4ÿÿÿ3À‰µ|ÿÿÿÇE€   f‰…lÿÿÿEŒÆEüP•lÿÿÿ¹à4@ èH1  ƒ}€lÿÿÿr‹lÿÿÿ‡¸   ƒxr‹ QPÿl¢B YY…À‹…ìşÿÿjuƒÈ@‰…<ÿÿÿ…<ÿÿÿPjVhø=@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèµE  ‹…Ôşÿÿj‰…<ÿÿÿ…<ÿÿÿPjVh 8@ ÿµ@ÿÿÿÿ`¡B …Àt‹ÈèE  ‡Ğ   ƒxr‹ PDÿÿÿèM¥şÿ…DÿÿÿÆEü‹@ÿÿÿº>@ PèF  \ÿÿÿºÜ@ ‹±;²uFƒşuòë jƒìµ\ÿÿÿ‹ü3Ò¥¥¥¥‹½4ÿÿÿ‹Ïèî  ‹Ïè7/  PM¨èç¤şÿE¨ÆEü‹@ÿÿÿº>@ Pè­E  M¨ÆEüè¯¢şÿƒ½$ÿÿÿu[‹Ïèú.  PM„èª¤şÿ3ÉÆEü	A‰,ÿÿÿ‰<ÿÿÿM„è=>  „Àt,‹ÏèË.  PM¨è{¤şÿjY‰,ÿÿÿM¨èş=  „ÀuÆ…(ÿÿÿ‹…,ÿÿÿ¨tƒàıM¨‰…,ÿÿÿè0¢şÿ‹…,ÿÿÿÇEü   ¨tM„è¢şÿ€½(ÿÿÿ u	²‹Ïèå  ‹Ïè  Dÿÿÿèó¡şÿlÿÿÿèè¡şÿMÀèà¡şÿMØèØ¡şÿƒ½0ÿÿÿ tÿµ0ÿÿÿÿx¡B ƒ½@ÿÿÿ tÿµ@ÿÿÿÿx¡B èw  Ã‹ B ú B t4öBt.€zr(MØèÁ£şÿPÿµ4ÿÿÿÿrÿrº°?@ jYèp­ÿÿ‹…4ÿÿÿPMœè)¡şÿhLˆB ‹ÁPèƒx  Ìhˆ   ¸CXB èvw  ‰•tÿÿÿ‹ùWMÔèC£şÿMÔèÏ<  MÔŠØè¡şÿ„Û…«   3ö‰µxÿÿÿƒì‰uü‹ÌÆEüWè£şÿM€è÷²ÿÿh  VÆEüÿ¬ B Pÿ¨ B ‹È…Éuè)Œşÿ‹È‰|ÿÿÿÆEü…ÉtQQ‹Ä‰0‰pE€Pè3*  ‹Øë‹Ş…ÛtğÿCM€‰xÿÿÿè8•ÿÿ‹•tÿÿÿ‹Ëj‰uüƒì‹üu¥¥¥¥è€  …Ût‹ËèCYÿÿèèu  Â ‹½lÿÿÿ‹‹0‹Îÿè£B ‹ÏÿÖƒøt‹‹0‹Îÿè£B ‹ÏÿÖ=Ÿ:  u¸BÇA Ã3öVVèTw  ÌhÜ   ¸¯XB èGv  ‰•0ÿÿÿ‹ñ‰µ<ÿÿÿ‰µ(ÿÿÿèS,  ‹øMÔW‰½Dÿÿÿèû¡şÿMÔè‡;  MÔˆ…OÿÿÿèÑŸşÿ€½Oÿÿÿ …Ö  3À‰Eà‰Eä‰EèMà‰EüètôÿÿWM¼è¹¡şÿM¼è_;  M¼ˆ…OÿÿÿèŸşÿ‹Eä‹Mà‰…$ÿÿÿ‰4ÿÿÿ;$ÿÿÿ„m  3À‰,ÿÿÿ‰EÈ‰EÌ‰EĞQPÿÿÿÆEüèSŞÿÿEÈÆEüPPÿÿÿèÒâÿÿPÿÿÿèìèÿÿÇEü   ‹MÌ‹uÈ‰Hÿÿÿ‰µ@ÿÿÿ;ñ„  ƒ~‹Ær‹WPÿl¢B YY…Àu.ÿµ0ÿÿÿ‹µ,ÿÿÿ‹<ÿÿÿƒì‹ü¥¥¥¥‹µ@ÿÿÿ‹VèÛ  é5  €½Oÿÿÿ „.  ƒ¥ÿÿÿ ƒìÆEü‹ÌVè©şÿhÿÿÿè¡°ÿÿh  j ÆEüÿ¬ B Pÿ¨ B ‹È…ÉuèÒ‰şÿ‹È‰ ÿÿÿÆEü…Ét!QQ‹Äƒ  ƒ` …hÿÿÿPè×'  ‹ø‰…8ÿÿÿë3ÿ‰½8ÿÿÿ…ÿtğÿGhÿÿÿ‰½ÿÿÿèÍ’ÿÿ‹<ÿÿÿÁ¸   ÇEü   ƒyr‹	‡¸   ƒxr‹ QPÿl¢B YY…Àu+ÿµ0ÿÿÿ‹µ,ÿÿÿƒì‹ü¥¥¥¥‹µ@ÿÿÿ‹½8ÿÿÿ‹Ï‹VèÑ  ÆEü…ÿt(‹ÏèVÿÿë¸ıÉA Ã‹…(ÿÿÿ‹µ@ÿÿÿÇEü   ‰…<ÿÿÿ‹½Dÿÿÿ‹HÿÿÿƒÆ$écşÿÿÆEü ëb¡ B = B t:ö@t4€xr.‹½ÿÿÿ‹‹0‹Îÿè£B ‹ÏÿÖ‹ B Pÿµ4ÿÿÿÿqÿqè¯îÿÿ¸|ÊA Ã‹…(ÿÿÿƒeü ‹½Dÿÿÿ‰…<ÿÿÿMÈè6œÿÿ‹4ÿÿÿƒÁéıÿÿ‹uà…öt‹Uè‹Î+Öƒâğèåşÿèlr  Ãh¼   ¸YB ès  ‹ñ‰µdÿÿÿ‰µ`ÿÿÿèˆ8  „À…[  3ÿ‰½hÿÿÿƒì‰}ü‹ÌÆEüVèš§şÿpÿÿÿè®ÿÿh  WÆEüÿ¬ B Pÿ¨ B ‹È…ÉuèÏ‡şÿ‹È‰lÿÿÿÆEü…ÉtQQ‹Ä‰8‰x…pÿÿÿPèÖ%  ‹ğë‹÷‰µlÿÿÿ…ötğÿFpÿÿÿ‰µhÿÿÿèÒÿÿ‹…dÿÿÿ‰}üë¸ËA Ã‹…`ÿÿÿ3ÿ‰}ü‹µhÿÿÿ‰µlÿÿÿ…öt8€¾ø    u$¸   ƒyr‹	ƒì¶è   ‹ü¥¥¥¥è@  ëZ2Ò‹Îè«ûÿÿëU3É‰}äÇEè   f‰MÔÆEüƒxr‹  2 < this.tokens.tokens.length &&
      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||
        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||
        this.tokens.matches1AtIndex(index + 2, tt.parenL))
    ) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
   processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }

   processExportDefault() {
    let exportedRuntimeValue = true;
    if (
      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||
      // export default async function
      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          ContextualKeyword._async,
        ))
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (
      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||
      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||
      this.tokens.matches3(tt._export, tt._default, tt.at)
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(tt._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
      // After this point, this is a plain "export default E" statement.
    } else if (
      shouldElideDefaultExport(
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; expor…Éu:‹uğ…öt3¡ `= `t[÷@ @  tR€xrLVÿpº O ¹É   ÿpè¢rşÿë4‹÷¡ `= `t1÷@ @  t(€xr"WQÿpº O ¹È   ÿpèkÈşÿ¸ÿÿ  ;ğv‹ğf‹Æ‹Môd‰    Y_^ÉÃ‹ÿU‹ìjÿh&d¡    PƒìD¡ a3Å‰EìSVWPEôd£    ‰eğ‰MÀ‹U3É‰UĞ‰MØ‰M¼‰MÜf‰Mà‰MÈ…Òu>‹5 `ş `„Š  ÷F @  tm€~rgQÿv» O ¹Ê   ÿv‹ÓèÇqşÿé(  ‹Eƒø$sLjWY‰MØ‹5 `ş `„>  ÷F @  t!€~rP» O ƒÁtÿv‹Óÿvè}qşÿéŞ  » O éİ  ‹5 `¿ @  ş `t2…~t-€~r'ÿr » O ¹Ì   ÿv‹Óÿvè6qşÿ‹5 `3É‹UĞë» O ‹B j<Z‰EÔ÷â‰Eä;Ñ‡0  r	ƒøÿ‡%  }Ô   ‹U‡  BÜ9Eä‡  ‹EÔ…Àu*ş `„m  …~„7  €~‚-  Q¹Î   é,ÿÿÿ‹uÀ€¾l   ‹5 `t8ş `t#…~t€~rÿv‹Ó¹Ï   ÿvèapşÿ‹5 `¹Ÿ  ‰MØéÛ  ‹uäƒÆ‰Mä‰uÄ…À„9  ‹MĞAX‰EØ‹UØEÜ‹ ;BÌ‹Uu=‹uØEÜ·@f;FĞ‹5 `u'ş `t|…~tw€~rqÿv‹Ó¹Ò   ÿvèæoşÿë]‹EØ‹0;ò‰uÔ‹5 `ƒ   ‹@;Âƒ’   ¨…Š   ‹uÔğ‰uÌ;ğ‹5 `rx9UÌwsMÔ3ÒÑèf9TAşu)‹UØ‹EÄBÿEÈ‰EÄ‹Mä‹EĞAƒEØ<‰Mä;H ss‹Èé<ÿÿÿjY‰MØş `„  …~„ß  €~‚Õ  ¹Ñ   ÿv‹Óÿvè6oşÿéµ  jY‰MØş `„Ù  …~„£  €~‚™  R¹Ğ   é•ıÿÿ‹uÄVÿô ‰E¼‰E´…Àu5jY‰MØ‹5 `ş `„  …~„Y  €~‚O  ¹Ó   éuÿÿÿ‹}¼V3öVWèµğ ‹EÈƒÄ‰‹ÎkÀ<‰MÌ‰uØƒÀÇ‰Eä‹EĞ9p †©   ‹Øw‰uÔ‹ÁS$‰UĞ;EÈƒ‰   EÜ‹ ;uEÜ·@f;Bt]‹‹}Ô‰Føf‹Bf‰FürjYó¥ÿr8‹B4ÃPÿuäè¿û ‹uÔƒÄ‹Mä‹Á‹UĞ‹}¼+Ç‰F,‹B8‰F0J8‹EØ@‰Mä‹MÌƒÆ<‰EØ‰uÔë‹EØAƒÂ<‰MÌ‰UĞ;K ‚nÿÿÿ» O 3ö‹EÀWÿuÄjÿp<ÿ¨ ‹È‰MØ…ÉtA‹5 `ş `„'  ÷F @  „  €~‚  Qÿv‹Ó¹Ô   ÿvè¢mşÿéï   ‰uü;uÈƒæ   kÎ<‰MÔ‹D9‰EÜf‹D9MÜf‰Eà‹EÀQMÌQˆP  èÙS  ‹MÀ‹EÌÁP  ;u$‹UÔÿu´‹D:‰Eäf‹D:f‰EèEäPQE¸Pèİ]  ‹MØFë‘jY‰MÌ¡ `= `t%÷@ @  t€xrQÿpº O ¹Õ   ÿpèôlşÿ¸ğ!Ã‹MÌ» O ‹}´‰MØë3‹UjWY‰MØş `ti…~t7€~r1Rÿv‹ÓƒÁvÿvè±lşÿ‹}¼‹MØ‹5 `…ÿtWÿ\ ‹5 `‹MØş `t%÷F @  t€~rQÿv‹Ó¹Ö   ÿvèglşÿ‹MØ‹Á‹Môd‰    Y_^[‹Mì3Íè¼á ÉÂ ‹ÿU‹ìƒìSV‹ÁW‰Eø‹5 `ş `t0÷F @  t'€~r!ÿuº O ¹×   ÿvÿvèlşÿ‹5 `‹Eø‹}3É‹Ùj4Z…ÿtm8ˆl  ue‹G ÷â‹Ø;Ñwrƒûÿw    w
‹EƒÀÜ;Øv@jW_ş `„e  ÷F @  „+  €~‚!  ¹Ø   ÿvº O ÿvèdkşÿé  sV‰uìÿô ‹Ø‰]ğ…Ûu3j_‹5 `ş `„	  ÷F @  „Ï   €~‚Å   ¹Ù   ë¢V3öVSèí ƒÄ…ÿtW‹Eø€¸l   uK‹G ‰9w vAK‹×w,‰Mü‰uô3Û‹FøC‹}ü‰Aøf‹Füf‰AüjYó¥‹uô‹MüƒÆ<ƒÁ4‰uô‰Mü;Z rÒ‹]ğ‹uøSÿuìjÿv<ÿ¨ ‹ø…ÿt1¡ `= `t%÷@ @  t€xrWÿpº O ¹Ú   ÿpèƒjşÿSÿ\ ‹5 `ş `t%÷F @  t€~rWÿvº O ¹Û   ÿvèIjşÿ‹Ç_^[ÉÂ ‹ÿU‹ìjÿh8&d¡    Pƒì4¡ a3Å‰EìSVWPEôd£    ‰eğ‰MÔ‹}¡ `= `t,÷@ @  t#€xrÿpº O ¹Ü   ÿpè¼işÿ¡ `‹MÔƒ} „  …ÿ„  Wÿujÿq<ÿ¨ ‹ğ…ötG¡ `= `„  ÷@ @  „Ü   €x‚Ò   Vÿpº O ¹İ   ÿpènişÿ¡ `é²   3Û‰]ü;síkË<‰MØ‹D9‰Eäf‹D9Mäf‰Eè‹EÔQP  MĞQ‹È‰EÌèŸO  ‹MÌ‹EĞ;u$‹UØÿuØ‹D:‰EÜf‹D:f‰EàEÜPQEÄPè©Y  Cë›jY‰MØ¡ `= `t%÷@ @  t€xrQÿpº O ¹Ş   ÿpèÃhşÿ¸!&Ã‹uØéGÿÿÿjW^= `t%÷@ @  t€xrVÿpº O ¹ß   ÿpè†hşÿ‹Æ‹Môd‰    Y_^[‹Mì3ÍèŞİ ÉÂ ‹ÿU‹ìQQSVW‹ `ù `t*÷A @  t!€yrÿqº O ÿq¹à   èhşÿ‹ `3Û9]„  ‹u…ö„   ‹Özf‹ƒÂf;Ãuõ+×Ñúƒúıƒã   9]„Ú   9]„Ñ   ‹ÎQf‹ƒÁf;Ãuõ+ÊÑùM   x@‰EüWÿô ‹ğ‰uø…öuEj[‹ `ù `„»   ÷A @  „   €yr{ÿqº O ÿq¹á   èUgşÿ‹ `ë^WSVèOé ‹M~Ç   ƒÄ‹‰Ff‹Af‰F‹ujYó¥‹uø‹}üWÿuF@Pè¡ô ‹EO@ÇF8@   ƒÄ‰~<‰0‹E‰ëj[ù `t%÷A @  t€yrSÿqº O ÿq¹â   èàfşÿ_^‹Ã[ÉÂ ‹ÿU‹ìƒìSVW‹ù‰}ô‹5 `ş `t0÷F @  t'€~r!‹Eº O ¹ã   ÿpÿvÿvèfşÿ‹5 `‹E3Éj4Z‹Ù‹@‰Eü÷â‰Eø;Ñ‡ı  r	ƒøÿ‡ò  ‹Müù   ‡æ  ‹EƒÀø9Eø‡×  8Ÿl  t<ş `t*÷F @  t!€~rÿvº O ¹å   ÿvèñeşÿ‹5 `¿Ÿ  éÚ  GPMèèCvşÿƒtC¿Ÿ  ¡ `= `t$÷@ @  t€xrÿpº O ¹æ   ÿpèšeşÿÿuìÿ¸é  ÿuìÿ¸‹uøƒÆV‰uìÿô ‹Ø‰]ğ…ÛuFj_‹5 `ş `„{  ÷F @  „A  €~‚7  ÿvº O ¹ç   ÿvè)eşÿé  Vj Sè%ç ‹UƒÄ‹B‰ƒz vB{3Ûr‰}ü‰uø‹FøC‰Gøf‹Füf‰GüjYó¥‹uø‹}üƒÆ4ƒÇ4‰uø‰}ü;ZrÕ‹]ğ‹}ô‹uìSV‹Ïèî   ‹ø…ÿt-‹5 `ş `„   ÷F @  „‚   €~r|W¹è   ë^‹EôSVjÿp<ÿ¨ ‹ø…ÿtX‹5 `ş `tP÷F @  tG€~rAW¹é   ë#‹MüjW_ş `ti÷F @  t3€~r-Q¹ä   ÿvº O ÿvè<dşÿ‹5 `…ÛtSÿ\ ‹5 `ş `t%÷F @  t€~rWÿvº O ¹ê   ÿvèøcşÿ‹Ç_^[ÉÂ ‹ÿU‹ìjÿhe&d¡    Pƒì,¡ a3Å‰EìSVWPEôd£    ‰eğ‹Ù‰]Ì3öjY‰uäf‰uè‰uĞ‰uÔèÅsÿÿ‰ ‰@‰@fÇ@‰EĞƒ}‰uüsGjW^¡ `= `„™  ÷@ @  „`  €x‚V  ÿuº O ¹ë   ÿpÿpèGcşÿé4  ÆEüƒ»T   „  “P  ‹‰UÈ‹ ‰EØ;tiÿuÌƒÀPQEÜPMĞèµS  MØè§qÿÿ‹EØ‹UÈëØjY‰MÌ¡ `= `t%÷@ @  t€xrQÿpº O ¹ì   ÿpèÂbşÿ¸",Ã‹uÌé¦   ‹E‹Ş90v]x‹ğMä‹;u
·Af;Gt8‹MĞ‰EÜf‹Gf‰EàEÜPEØPèêH  ‹EØ;EĞtPMĞèÕrÿÿjZ‹Èè¥uÿÿCƒÇ4;r­‹UÈ3ö‹MĞ‹‰EØ;ÁtƒÀ‹ÊPèI  MØèÕpÿÿ‹EØ‹UÈ;EĞuâ‹]Ìƒ}Ô tEĞ‹ËPèm   ‹ğ¡ `= `t%÷@ @  t€xrVÿpº O ¹í   ÿpèİaşÿ‹EĞÿpEĞP‹Èè›Q  ‹MĞjZèuÿÿ‹Æ‹Môd‰    Y_^[‹Mì3Íè× ÉÂ ‹ÿU‹ìƒìS‹]VWj<‹C‰MôY÷á…Ò‡(  r	ƒøÿ‡  p‰uø;ğ‚í   Vÿô ‹ø…ÿuIj^¡ `= `„U  ÷@ @  „  €x‚  ÿpº O ¹ñ   ÿpèÿ`şÿ¡ `éó   Vj Wèöâ ‹CƒÄ‰‹‹‰Eü;Át(‹u_‹H‰Müf‹@f‰Cè‚oÿÿ‹Eü[<;uá‹uø‹EôWVjÿp<ÿ¨ ‹ğ…öt1¡ `= `t%÷@ @  t€xrVÿpº O ¹ò   ÿpèˆ`şÿWÿ\ é_ÿÿÿ¡ `= `tK÷@ @  tB€xr<¹ğ   ë ¡ `= `t)÷@ @  t €xr¹ï   ÿpº O ÿpè`şÿ¡ `¾  = `t%÷@ @  t€xrVÿpº O ¹ó   ÿpèô_şÿ_‹Æ^[ÉÂ ‹ÿU‹ìƒìSVW‰Mô3ÀMøˆEÿQh P¿°# ‰EøWh  €‰EğÿŒ‹ğ» `…ö„   ƒştNş  tF‹ `;Ë„2  ÷A @  „%  €y‚  Vÿqÿq¹õ   º O è`_şÿ‹ `éú  ‹ `;Ët+÷A @  t"€yrWÿqº O ÿq¹ô   è^øşÿ‹ `3ÿ‹÷ë‹ `3ÿƒ}ø „§   Eè‰}ìPEìÇEè   PWjhdM Wÿuøÿˆ‹ğ…ö„  ƒşt>ş  t6‹ `;Ë„d  ÷A @  „W  €y‚M  Vÿqÿq¹÷   é-ÿÿÿ‹ `;Ët*÷A @  t!€yrÿqº O ÿq¹ö   èK^şÿ‹ `‹÷ŠEÿ;Ët.÷A @  t%€yr¶Àº O Pÿqÿq¹ø   è2^şÿ‹ `‹Eô€xy …Ä   €}ÿ „º   Mğ‰}èQMèQjÿp<ÿä ‹ğ…ötG‹ `;Ë„   ÷A @  „ƒ   €yr}Vÿqÿq¹ù   é]şÿÿƒ}ì ‹ `—ÀˆEÿéTÿÿÿ‹Eğ‹H…Étƒx„‡   G  ;ùrì‹ `;Ët*÷A @  t!€yrÿqº O ÿq¹ú   èH]şÿ‹ `¾  ‹Eğ…ÀtPÿà ‹ `;Ët%÷A @  t€yrVÿqº O ÿq¹ş   è]şÿ_‹Æ^[ÉÃ‹MôpƒÁT‹ù¥¥¥¥¡ `;Ãt%÷@ @  t€xrQÿpº O ¹û   ÿpèTªÿÿ‹}ô‹ÏG{Pjè—  ‹ğ…öt6‹ `;Ë„[ÿÿÿ÷A @  „Nÿÿÿ€y‚DÿÿÿVÿqÿq¹ü   é$ıÿÿjj‹ÏèŞ  ‹ğ…öt6‹ `;Ë„ÿÿÿ÷A @  „ÿÿÿ€y‚ışÿÿVÿqÿq¹ı   éİüÿÿÆGyéŞüÿÿ‹ÿU‹ìS‹ÙV3öW€{z …š   ‹u{DC|Pj ¶”   ¥¥¥¥èÚ  ‹ğ…öt9‹ `ù `„š   ÷A @  td€yr^Vÿqÿq¹ÿ   º O èĞ[şÿë@jj ‹Ëè  ‹ğ…öt+‹ `ù `tT÷A @  t€yrVÿqÿq¹   ë¸ÆCz‹ `ù `t%÷A @  t€yrVÿqº O ÿq¹  è[[şÿ_‹Æ^[]Â ‹ÿSVW‹ù3ö» @  €y tG¶G{Pjè  ‹ğ…öt1‹ `ù `tV…Yt(€yr"Vÿqº O ÿq¹  èıZşÿëÆGy ‹ `ù `t!…Yt€yrVÿqº O ÿq¹  èÈZşÿ_‹Æ^[Ã‹ÿSVW‹ù3ö» @  €z tF¶G|PVèş   ‹ğ…öt1‹ `ù `tV…Yt(€yr"Vÿqº O ÿq¹  ènZşÿëÆGz ‹ `ù `t!…Yt€yrVÿqº O ÿq¹  è9Zşÿ_‹Æ^[Ã‹ÿU‹ìQQVW3ÿEüWPEø‰}øP¶EÁàWƒÀD‰}üjÁPÿq@ÿ` ‹ğ…öuM‹Uü‹M9:•Àˆ‹ `ù `t+÷A @  t"€yr¶Àº O Pÿqÿq¹  è·Yşÿ‹UüRÿ\ _‹Æ^ÉÂ ‹ÿU‹ìQQSV‹ñ‹ `Š]ú `t(÷B @  t€zr¶Ã¹  Pÿrÿrº O èaYşÿj ¶Ã‰EüEüP¶EÁàjƒÀDjÆPÿv@ÿè ^[ÉÂ ÌÌÌÌÌÌÌ‹ÿU‹ìƒäøQSVW‹ `¸ `‹}» @  ‹u;Èt-…Yt(€yr"WVÿqº O ÿq¹  èå®şÿ‹ `¸ `ƒd$ …ö„m  …ÿ„e  ‹Vú   „·  ú  „Í  ú  „¼   ‚øÿïÿƒøww¿ `;Ït!…Yt€yrRÿqº O ÿq¹  èjXşÿL$èîÉÿÿ…Àt/‹ `;Ï„  …Y„  €y‚  Pÿqÿq¹  ë<ÿv‹L$è  éâ  ù `„Ö  …Y„Í  €y‚Ã  Rÿqÿq¹  º O èèWşÿé¨  ‹~º@  …ÿ„Å   9V‚¼   ;Èt)…Yt$€yrÿwº O ÿqÿq¹  è£Wşÿ‹ `‹Gƒøt5ƒøt0ù `„I  …Y„@  €y‚6  Pÿqÿq¹  énÿÿÿL$èäÈÿÿ…Àt6‹ `ù `„  …Y„ı  €y‚ó  Pÿqÿq¹  é+ÿÿÿ‹L$Wè;  éÓ  ;È„Ë  …Y„Â  €y‚¸  RÿvWÿqÿq¹  éÏ   ‹~…ÿ„•   ~  ‚ˆ   L$èJÈÿÿ…Àt6‹ `ù `„l  …Y„c  €y‚Y  Pÿqÿq¹  é‘şÿÿƒ…>  ¡ `= `t …Xt€xrÿpº O ¹  ÿpè/Vşÿ‹L$WèÕ  é  ;È„û   …Y„ò   €y‚è   h  ÿvWÿqÿq¹
  º O èJîşÿéÅ   ƒ~ º8  tn9Vri;Èt …Yt€yrÿqº O ÿq¹  è®UşÿL$èPÇÿÿ…Àt*‹ `ù `tv…Ytq€yrkPÿqÿq¹  é£ıÿÿÿv‹L$èW   ëL;ÈtH…YtC€yr=Rÿvÿvÿqÿq¹  éRÿÿÿ;Èt"…Yt€yrWVÿqº O ÿq¹	  è:«şÿ_^[‹å]Â ‹ÿU‹ìƒìƒeø SV‹uW‹ù…öujWXé3  ‹ `ù `t'÷A @  t€yrFPPÿ¶œ   ÿvÿqÿqè­ŸÿÿGPMğè!eşÿ‹OƒùtC¿Ÿ  ¡ `» O = `t"÷@ @  t€xrQÿp‹Ó¹  ÿpè‘Tşÿÿuôÿ¸ëwEø‹ÏPFPPè¨  ‹ø» O …ÿt;‹ `ù `t"÷A @  t€yrWÿq‹Óÿq¹  è<Tşÿÿuôÿ¸ëÿuôÿ¸‹MøVè's  ‹øƒ}ø t‹MøèÄ\  ¡ `= `t"÷@ @  t€xrWÿp‹Ó¹  ÿpèáSşÿ‹Ç_^[ÉÂ ‹ÿU‹ìƒìƒeø SV‹uW‹ù…öujWXé-  ‹ `ù `t!÷A @  t€yrFXPÿvÿqÿqè(ÿÿGPMğèÍcşÿ‹OƒùtC¿Ÿ  ¡ `» O = `t"÷@ @  t€xrQÿp‹Ó¹  ÿpè=Sşÿÿuôÿ¸ëwEø‹ÏPFXPèT
  ‹ø» O …ÿt;‹ `ù `t"÷A @  t€yrWÿq‹Óÿq¹  èèRşÿÿuôÿ¸ëÿuôÿ¸‹MøVè&u  ‹øƒ}ø t‹Møèp[  ¡ `= `t"÷@ @  t€xrWÿp‹Ó¹  ÿpèRşÿ‹Ç_^[ÉÂ ‹ÿU‹ìjÿh’&d¡    Pƒì SVW¡ a3ÅPEôd£    ‰eğ‹ù‰}à‹ `ú `t.÷B @  t%€zr‹MQÿr¹  ÿrº O èRşÿ‹ `‹E3öøÿïÿƒø‡  GPMØèGbşÿ‰uü¡ `= `t'÷@ @  t€xrÿuº O ¹   ÿpÿpèÁQşÿÇl  ÆEü‹G‹OÁ¨uAÁè9GwQ‹ÏèK>  ‹G…ÿÿÿÿ!G‹WW‹O‹ÂÁèI#È‰Uä‹G‰Mè94ˆujYè†aÿÿ‹Mè‹Ğ‹G‰ˆ‹G‹Uä‹ˆƒâ‹MÿuÜ‰ÿGÿ¸‹Eà  PVh°@ÿ,‚…Àu3j^ëÇEè   ¸Î=ÃÿuÜÿ¸‹uè‹ `ëMÇEè  ¸Î=ÃPÿ(‚ëâú `t*÷B @  t!€zrÿr¹!  ÿrº O èœPşÿ‹ `¾Ÿ  ú `t%÷B @  t€zrVÿr¹"  ÿrº O è‚Pşÿ‹Æ‹Môd‰    Y_^[ÉÂ ‹ÿU‹ìƒìƒeø VW‹}‹ñ…ÿujWXé:  ‹ `ù `t(÷A @  t€yrG º O Pÿqÿq¹#  è¯éşÿFPMğè]`şÿƒ~t@¾Ÿ  ¡ `= `t$÷@ @  t€xrÿpº O ¹$  ÿpè´Oşÿÿuôÿ¸ëEø‹ÎPG Pè±	  ‹ğ…ötHş  u3öë1¡ `= `t%÷@ @  t€xrVÿpº O ¹%  ÿpèuOşÿÿuôÿ¸ëÿuôÿ¸‹MøWèƒt  ‹ğƒ}ø t‹MøèıW  ¡ `= `t%÷@ @  t€xrVÿpº O ¹&  ÿpèOşÿ‹Æ_^ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒäøQSVW¡ `» `¿ @  ;Ãt …xt€xrÿpº O ¹'  ÿpè¡Nşÿƒd$ L$è>Àÿÿ‹ğ…öt-‹ `;Ëtj…yt@€yr:Vÿqº O ÿq¹(  è€Nşÿë‹E‹L$Pƒx4 uè–  ëè©  ‹ğ‹ `;Ët!…yt€yrVÿqº O ÿq¹)  è7Nşÿ_^[‹å]Â ‹ÿU‹ìƒäøQSVW¡ `» `¿ @  ;Ãt …xt€xrÿpº O ¹*  ÿpèÑMşÿƒd$ L$èn¿ÿÿ‹ğ…öt-‹ `;ËtW…yt-€yr'Vÿqº O ÿq¹+  è°Mşÿë	‹L$è4   ‹ `;Ët!…yt€yrVÿqº O ÿq¹,  èzMşÿ_^[‹å]Â ‹ÿU‹ìjÿh­&d¡    Pìô  ¡ a3Å‰EğSVWPEôd£    ‹ñ¡ `= `t$÷@ @  t€xrÿpº O ¹-  ÿpèñLşÿ¸À  3ÛP…0şÿÿSPèæÎ ƒÄ½ şÿÿ3ÀjYó«F$Pşÿÿè+]şÿFP şÿÿè]şÿ9|  uH¡ `¿ `;Çt$÷@ @  t€xrÿpº O ¹.  ÿpètLşÿÿµ$şÿÿ»Ÿ  ÿ¸éS  ‹†l  ‹Ó‹¾x  …Àt‹‹B‹ÏÁéƒçH#È‹B‹ˆ‹<¸ƒ®|  u‰x  ëÿ†x  ¡ `= `t%÷@ @  t€xrWÿpº O ¹/  ÿpè	Lşÿ‹†€   ÿµ$şÿÿ‰…,şÿÿ‹†„   ‰…(şÿÿÿ¸Ç…0şÿÿÀï	  tƒïtjëjëjY‰4şÿÿ¡ `¿ `;Çt*÷@ @  t!€xrQÿpº O ¹0  ÿpèŠKşÿ¡ `‹µ,şÿÿ…ötW… şÿÿ‹ÎP…0şÿÿPÿµ(şÿÿÿ„ƒÿÖ‹Ø…Ût.¡ `;ÇtS÷@ @  t!€xrSÿpº O ¹1  ÿpè)Kşÿ¡ `;Çt%÷@ @  t€xrSÿpº O ¹2  ÿpèûJşÿÿµşÿÿÿ¸‹Môd‰    Y_^[‹Mğ3ÍèIÀ ÉÃ‹ÿU‹ìƒì¡ a3Å‰EøSVW‹}‹ñ¡ `» @  = `t&…Xt!€xrWÿpº O ¹3  ÿpè‰Jşÿ¡ `…ÿujW^é‚   FPMèè¼Zşÿ‹Gt‹Î‰Eğf‹Gxf‰EôEğj PèJ  ‹ğ…öt9ş  u3öë-¡ `= `t!…Xt€xrVÿpº O ¹4  ÿpèJşÿÿuìÿ¸‹ÏèdW  ‹Ïè°R  ¡ `= `t!…Xt€xrVÿpº O ¹5  ÿpèÎIşÿ‹Mø‹Æ_^3Í[è1¿ ÉÂ ‹ÿU‹ìƒìSVW‹ñ¡ `» @  = `t%…Xt €xrÿpº O ¹6  ÿpè_Işÿ¡ `‹}…ÿujW^ëlFPMôè°Yşÿj ÿw@‹Îè<  ‹ğ…öt9ş  u3öë-¡ `= `t!…Xt€xrVÿpº O ¹7  ÿpèIşÿÿuøÿ¸‹ÏèºQ  ¡ `= `t!…Xt€xrVÿpº O ¹8  ÿpèØHşÿ_‹Æ^[ÉÂ ‹ÿU‹ìjÿhİ&d¡    Pƒì<¡ a3Å‰EìSVWPEôd£    ‰eğ‹ù‰}Ô‹E‹M‰EØ3À‰Mà‰EÜ‰EÄ‰Eü‹5 `ş `t.÷F @  t%€~rQÿvº O ¹9  ÿvèæáşÿ‹5 `‹MàÆEüÇ@  ‹‰Eäf‹A‹Ïf‰EèEäPEĞ‰}ÌPèª0  ‹EĞ;tK¿É  ş `„Ù  ÷F @  „Ì  €~‚Â 