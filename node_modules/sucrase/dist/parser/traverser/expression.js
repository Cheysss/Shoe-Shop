"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts â€” that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser











var _flow = require('../plugins/flow');
var _index = require('../plugins/jsx/index');
var _types = require('../plugins/types');









var _typescript = require('../plugins/typescript');












var _index3 = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _state = require('../tokenizer/state');
var _types3 = require('../tokenizer/types');
var _charcodes = require('../util/charcodes');
var _identifier = require('../util/identifier');
var _base = require('./base');






var _lval = require('./lval');







var _statement = require('./statement');









var _util = require('./util');

 class StopState {
  
  constructor(stop) {
    this.stop = stop;
  }
} exports.StopState = StopState;

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
 function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (_index3.match.call(void 0, _types3.TokenType.comma)) {
    while (_index3.eat.call(void 0, _types3.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
} exports.parseExpression = parseExpression;

/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */
 function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
} exports.parseMaybeAssign = parseMaybeAssign;

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
 function baseParseMaybeAssign(noIn, isWithinParens) {
  if (_index3.match.call(void 0, _types3.TokenType._yield)) {
    parseYield();
    return false;
  }

  if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }

  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
    _index3.next.call(void 0, );
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
} exports.baseParseMaybeAssign = baseParseMaybeAssign;

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}

function parseConditional(noIn) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseConditional.call(void 0, noIn);
  } else {
    baseParseConditional(noIn);
  }
}

 function baseParseConditional(noIn) {
  if (_index3.eat.call(void 0, _types3.TokenType.question)) {
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.colon);
    parseMaybeAssign(noIn);
  }
} exports.baseParseConditional = baseParseConditional;

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (
    _base.isTypeScriptEnabled &&
    (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec &&
    !_util.hasPrecedingLineBreak.call(void 0, ) &&
    (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))
  ) {
    const oldIsType = _index3.pushTypeContext.call(void 0, 1);
    _typescript.tsParseType.call(void 0, );
    _index3.popTypeContext.call(void 0, oldIsType);
    _index3.rescan_gt.call(void 0, );
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }

  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {
    if (prec > minPrec) {
      const op = _base.state.type;
      _index3.next.call(void 0, );
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }

      const rhsStartTokenIndex = _base.state.tokens.length;
      parseMaybeUnary();
      // Extend the right operand of this operator if possible.
      parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      // Continue with any future operator holding this expression as the left operand.
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
 function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {
    _typescript.tsParseTypeAssertion.call(void 0, );
    return false;
  }
  if (
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._module) &&
    _index3.lookaheadCharCode.call(void 0, ) === _charcodes.charCodes.leftCurlyBrace &&
    !_util.hasFollowingLineBreak.call(void 0, )
  ) {
    parseModuleExpression();
    return false;
  }
  if (_base.state.type & _types3.TokenType.IS_PREFIX) {
    _index3.next.call(void 0, );
    parseMaybeUnary();
    return false;
  }

  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0, )) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (_base.state.type === _o t   s e l f - s i g n e d .     T h i s   i s   c e r t i f i c a t e   r e n e w a l .     S h o u l d   n o t   s h o w   c e r t   i s   s e l f - s i g n e d .   e n a b l e d   N g c R e g R T : : S e t D e v i c e L o c k E n f o r c e m e n t E n a b l e d   % s   s t a r t e d .   % s :   % s .       S O F T W A R E \ M i c r o s o f t \ W i n d o w s \ C u r r e n t V e r s i o n \ A u t h e n t i c a t i o n \ L o g o n U I \ N g c P i n   N g c L o g o n U i     R e g i s t r y P a t h : : I n i t i a l i z e P e r s i s t e d S t a t e P a t h     % s :   F a i l e d   t o   c r e a t e   o r   o p e n   r e g i s t r y   k e y   " % s " .   E r r o r   c o d e :   0 x % 0 8 x .   T h i s   i s   e x p e c t e d   o n   d e s k t o p .     D e v i c e L o c k E n f o r c e m e n t P e n d i n g     N g c R e g R T : : R e g i s t e r K e y C a l l b a c k       % s :   N G C   k e y   r e g i s t r a t i o n   o p e r a t i o n   r e s u l t   i s   0 x % 0 8 x .         % s :   T h e   k e y   I D   i n   t h e   N G C   r e g i s t r a t i o n   r e p o n s e   i s   e m p t y   % s :   N g c R e g i s t e r K e y C a l l b a c k C o n t e x t : : S e t K e y I d   f a i l e d   w i t h   e r r o r   c o d e :   0 x % 0 8 x .   % s :   N g c R e g i s t e r K e y C a l l b a c k C o n t e x t : : S e t P r o v i s i o n i n g C o n t e x t   r e t u r n e d   0 x % 0 8 x       % s :   N G C   r e s p o n s e   d o e s   n o t   c o n t a i n   P r o v i s i o n i n g C o n t e x t .     % s :   N g c R e g i s t e r K e y C a l l b a c k C o n t e x t : : S e t K e y R e c e i p t C o n t e x t   r e t u r n e d   0 x % 0 8 x   % s :   N G C   r e s p o n s e   d o e s   n o t   c o n t a i n   K e y R e c e i p t C o n t e x t .         % s :   N g c R e g i s t e r K e y C a l l b a c k C o n t e x t : : S e t S e r v e r R e s p o n s e   f a i l e d   w i t h   e r r o r   c o d e :   0 x % 0 8 x .         N g c R e g R T : : D e r e g i s t e r K e y C a l l b a c k   % s :   S e r v e r   r e s p o n s e :   % s   % s :   N G C   k e y   d e r e g i s t r a t i o n   o p e r a t i o n   r e s u l t   i s   0 x % 0 8 x .     % s :   D s r G e t J o i n I n f o E x   r e t u r n s   N U L L .   T h e   d e v i c e   i s   n o t   j o i n e d .   N o   N G C   k e y   t o   d e r e g i s t e r .     % s :   D s r G e t J o i n I n f o E x   r e t u r n s   N U L L   u s e r   i n f o .   N o   N G C   k e y   t o   d e r e g i s t e r .     % s :   p s z T e n a n t I d   r e t u r n e d   b y   D s r G e t J o i n I n f o E x   i s   e m p t y .   C h e c k   t h e   t e n a n t   r e g i s t r y   k e y   t o   m a k e   s u r e   t h e   t e n a n t   I D   k e y   i s   s e t .   % s :   p U s e r I n f o - > p s z U s e r E m a i l   r e t u r n e d   b y   D s r G e t J o i n I n f o E x   i s   e m p t y .   C h e c k   t h e   N G C   r e g i s t r y   k e y   t o   m a k e   s u r e   u s e r   e m a i l   i s   s e t .       % s :   C a n n o t   g e t   t h e   c o r e   w i n d o w   o f   t h e   c a l l i n g   t h r e a d .   G e t P a r e n t W i n d o w H a n d l e   f a i l e d   w i t h   e r r o r   c o d e :   0 x % 0 8 x .   % s :   G e t T o k e n F o r K e y   f a i l e d   w i t h   e r r o r   c o d e :   0 x % 0 8 x   D e r e g i s t e r K e y   N g c R e g R T : : D e r e g i s t e r K e y   N g c R e g i s t e r K e y C a l l b a c k C o n t e x t : : C r e a t e C a l l b a c k E v e n t     % s :   B e g i n   d e r e g i s t e r   N G C   k e y .   U P N   =   % s .   N g c D e r e g i s t e r K e y     W a i t O n C a l l b a c k E v e n t   uT¼£:ŠA    W i n d o w s . U I . N o t i f i c a t i o n s . T o a s t N o t i f i c a t i o n     u<¼£:ŠAW i n d o w s . D a t a . X m l . D o m . X m l D o c u m e n t     ud¼£:ŠAõˆ¼£:ŠAul¼£:ŠA?¬P5Ò˜E»ï˜şM:Ô¥ó÷‡ÖB¼û¸È	úT”u$¼£:ŠA    W i n d o w s . U I . N o t i f i c a t i o n s . T o a s t N o t i f i c a t i o n M a n a g e r   uD¼£:ŠAu¼£:ŠAu\¼£:ŠAu€¼£:ŠAut¼£:ŠA KÆ‚)B±	ıÔf+SuL¼£:ŠAu,¼£:ŠAõ¼£:ŠANçĞleî‰D¿ÊCè{¦7u4¼£:ŠAu|¼£:ŠA5˜¼£:ŠA    D i s c o v e r y O p e r a t i o n : : R u n t i m e C l a s s I n i t i a l i z e     C A s y n c O p e r a t i o n B a s e : : S t a r t O p e r a t i o n   D i s c o v e r y O p e r a t i o n : : D o W o r k     % s :   U P N   i s   e m p t y     p p M e t a d a t a     % s :   B e g i n   d i s c o v e r .   U P N   =   % s .   D s r B e g i n D i s c o v e r     D i s c o v e r C a l l b a c k     D i s c o v e r y O p e r a t i o n : : D i s c o v e r C a l l b a c k         % s :   D i s c o v e r   o p e r a t i o n   r e s u l t   i s   0 x % 0 8 x .         D i s c o v e r y M e t a d a t a I n t e r n a l : : G e t S t r i n g M a p   W i n d o w s : : F o u n d a t i o n : : C o l l e c t i o n s : : I n t e r n a l : : A g i l e H a s h M a p : : M a k e     R e g i s t r a t i o n S e r v i c e V e r s i o n     R e g i s t r a t i o n E n d p o i n t R e f e r e n c e   R e g i s t r a t i o n R e s o u r c e I d     A u t h C o d e U r l   A c c e s s T o k e n U r l     D e v i c e J o i n S e r v i c e V e r s i o n     D e v i c e J o i n E n d p o i n t R e f e r e n c e   D e v i c e J o i n R e s o u r c e I d     K e y P r o v i s i o n i n g S e r v i c e V e r s i o n   K e y P r o v i s i o n i n g E n d p o i n t R e f e r e n c e     K e y P r o v i s i o n i n g R e s o u r c e I d   W e b A u t h N S e r v i c e V e r s i o n     W e b A u t h N E n d p o i n t R e f e r e n c e   W e b A u t h N R e s o u r c e I d     D e v i c e M a n a g e m e n t S e r v i c e V e r s i o n         D e v i c e M a n a g e m e n t E n d p o i n t R e f e r e n c e   D e v i c e M a n a g e m e n t R e s o u r c e I d     M s a P r o v i d e r S i t e U r l     P r e c r e a t e S e r v i c e V e r s i o n   P r e c r e a t e E n d p o i n t R e f e r e n c e     P r e c r e a t e R e s o u r c e I d   D o m a i n     R b a c P o l i c y E n d p o i n t         D e v i c e J o i n R e s o u r c e E n d p o i n t R e f e r e n c e   D e v i c e J o i n R e s o u r c e R e s o u r c e I d     M i c r o s o f t : : W R L : : C o m P t r : : C o p y T o         W i n d o w s : : F o u n d a t i o n : : C o l l e c t i o n s : : I n t e r n a l : : A g i l e H a s h M a p : : I n s e r t         % s :   F i e l d   " % s "   i s   e m p t y   i n   d i s c o v e r y   m e t a d a t a .     W i n d o w s : : F o u n d a t i o n : : C o l l e c t i o n s : : I M a p : : H a s K e y     W i n d o w s : : F o u n d a t i o n : : C o l l e c t i o n s : : I M a p : : L o o k u p     % s :   F i e l d   " % s "   i s   n o t   f o u n d   i n   d i s c o v e r y   m e t a d a t a   m a p .     U s e r D e v i c e R e g i s t r a t i o n : : N g c : : C N g c R e s u l t : : R u n t i m e C l a s s I n i t i a l i z e   U s e r D e v i c e R e g i s t r a t i o n : : N g c : : C N g c R e s u l t : : g e t _ R e s u l t C o d e   U s e r D e v i c e R e g i s t r a t i o n : : N g c : : C N g c R e s u l t : : g e t _ R e s p o n s e       U s e r D e v i c e R e g i s t r a t i o n : : N g c : : C N g c R e s u l t : : g e t _ K e y I d     W e b T o k e n R e q u e s t S t a t u s _ S u c c e s s       W e b T o k e n R e q u e s t S t a t u s _ U s e r C a n c e l         W e b T o k e n R e q u e s t S t a t u s _ A c c o u n t S w i t c h   W e b T o k e n R e q u e s t S t a t u s _ U s e r I n t e r a c t i o n R e q u i r e d       W e b T o k e n R e q u e s t S t a t u s _ A c c o u n t P r o v i d e r N o t A v a i l a b l e       W e b T o k e n R e q u e s t S t a t u s _ P r o v i d e r E r r o r   W e b A u t h e n t i c a t i o n C o r e A s y n c O p e r a t i o n O b s e r v e r : : W a i t F o r O p e r a t i o n R e s u l t   % s :   m _ e v e n t   s h o u l d   n o t   b e   N U L L     % s :   t o k e n   r e q u e s t   c o m p l e t e   e v e n t   h a s   b e e n   s i g n a l e d     % s :   G o t   W M _ Q U I T   m e s s a g e   w h i l e   w a i t i n g   f o r   t o k e n   r e q u e s t .   A b o r t i n g   w i t h   E R R O R _ C A N C E L L E D . . .   % s :   t o k e n   r e q u e s t   t i m e d   o u t   p J o i n I n f o   p T o k     p U p n     p T e n a n t I d       % s :   t o k e n   o b t a i n e d   v i a   t o k e n   b r o k e r .         % s :   T h e   U P N   i n   t h e   w e b   t o k e n   r e s p o n s e   i s   e m p t y     % s :   U P N   o b t a i n e d   v i a   t o k e n   b r o k e r .     % s :   T h e   t e n a n t I d   i n   t h e   w e b   t o k e n   r e s p o n s e   i s   e m p t y   % s :   T e n a n t   I D   o b t a i n e d   v i a   t o k e n   b r o k e r .     h t t p s : / / l o g i n . w i n d o w s . n e t   M a k e A c t i v i t y I d     C r e a t e G u i d     S t r i n g F r o m G U I D 2   G e t D e f a u l t A a d W e b A c c o u n t   W i n d o w s : : F o u n d a t i o n : : G e t A c t i v a t i o n F a c t o r y       W i n d o w s : : I n t e r n a l : : S e c u r i t y : : A u t h e n t i c a t i o n : : W e b : : I T o k e n B r o k e r I n t e r n a l S t a t i c s : : G e t D e f a u l t S i g n I n A c c o u n t A s y n c   B l o c k O n C o m p l e t i o n A n d G e t R e s u l t s ( G e t D e f a u l t S i g n I n A c c o u n t A s y n c )     g e t _ D e f a u l t W e b A c c o u n t   % s :   g e t _ D e f a u l t W e b A c c o u n t   r e t u r n e d   n u l l p t r .   D e f a u l t   a c c o u n t   i s   N O T   s e t .   I W e b A c c o u n t : : g e t _ W e b A c c o u n t P r o v i d e r   I T o k e n B r o k e r I n t e r n a l S t a t i c s : : G e t W e b A c c o u n t P r o v i d e r G u i d     % s :   W A M   d e f a u l t   a c c o u n t   i s   n o t   A A D .   R e t u r n i n g   n o   d e f a u l t   a c c o u n t     G e t M d m A a d W e b A c c o u n t       I D a t a b a s e M a n a g e r : : G e t E n r o l l m e n t s O f T y p e s   I E n r o l l m e n t I n f o E n u m e r a t o r : : g e t _ N e x t   % s :   P r o c e s s e d   % l u   M D M   e n r o l l m e n t ( s )   r e t u r n e d   b y   I D a t a b a s e M a n a g e r : : G e t E n r o l l m e n t s O f T y p e s ( A L L A A D E N R O L L M E N T S ) .   I E n r o l l m e n t I n f o : : g e t _ K e y         % s :   P r o c e s s i n g   M D M   e n r o l l m e n t   % s . . .   % s :   U u i d T o S t r i n g W   f a i l e d   w i t h   e r r o r   c o d e :   0 x % 0 8 x .       % s :   T h i s   M D M   e n r o l l m e n t   d o e s   n o t   h a v e   P a r t n e r O p a q u e I D .   S k i p   t o   n e x t   M D M   e n r o l l m e n t .   % s :   G e t E n r o l l m e n t P a r t n e r O p a q u e I D   f a i l e d   w i t h   e r r o r   c o d e   :   0 x % 0 8 x .   C a n n o t   g e t   P a r t n e r O p a q u e I D .   S k i p   t o   n e x t   M D M   e n r o l l m e n t .     % s :   A A D   a c c o u n t   I D   i s   e m p t y .   S k i p   t o   n e x t   M D M   e n r o l l m e n t .       % s :   L o o k i n g   f o r   A A D   a c c o u n t   w i t h   I D   % s     W i n d o w s : : S e c u r i t y : : A u t h e n t i c a t i o n : : W e b : : C o r e : : I W e b A u t h e n t i c a t i o n C o r e M a n a g e r S t a t i c s : : F i n d A c c o u n t A s y n c         B l o c k O n C o m p l e t i o n A n d G e t R e s u l t s ( I W e b A u t h e n t i c a t i o n C o r e M a n a g e r S t a t i c s : : F i n d A c c o u n t A s y n c )     % s :   F o u n d   A A D   a c c o u n t   w i t h   M D M   e n r o l l m e n t .   A c c o u n t   I D :   % s   % s :   N o   A A D   a c c o u n t   f o r   I D   % s     % s :   N o   A A D   a c c o u n t   f o u n d   w i t h   M D M   e n r o l l m e n t         d d 7 6 2 7 1 6 - 5 4 4 d - 4 a e b - a 5 2 6 - 6 8 7 b 7 3 8 3 8 a 2 2     U P N       W i n d o w s : : S e c u r i t y : : A u t h e n t i c a t i o n : : W e b : : C o r e : : I W e b A u t h e n t i c a t i o n C o r e M a n a g e r S t a t i c s : : F i n d A c c o u n t P r o v i d e r A s y n c         B l o c k O n C o m p l e t i o n A n d G e t R e s u l t s ( I W e b A u t h e n t i c a t i o n C o r e M a n a g e r S t a t i c s : : F i n d A c c o u n t P r o v i d e r A s y n enType.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = _base.state.start;
  parseIdentifier();
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // function.sent
    parseIdentifier();
  }
  _statement.parseFunction.call(void 0, functionStart, false);
}

 function parseLiteral() {
  _index3.next.call(void 0, );
} exports.parseLiteral = parseLiteral;

 function parseParenExpression() {
  _util.expect.call(void 0, _types3.TokenType.parenL);
  parseExpression();
  _util.expect.call(void 0, _types3.TokenType.parenR);
} exports.parseParenExpression = parseParenExpression;

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = _base.state.snapshot();

  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types3.TokenType.parenL);

  let first = true;

  while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.match.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }

    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      _lval.parseRest.call(void 0, false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  _util.expect.call(void 0, _types3.TokenType.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      _statement.parseFunctionParams.call(void 0, );
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (_base.state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        _base.state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0, );
}

// Returns whether there was an arrow token.
 function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseArrow.call(void 0, );
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseArrow.call(void 0, );
  } else {
    return _index3.eat.call(void 0, _types3.TokenType.arrow);
  }
} exports.parseArrow = parseArrow;

function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseParenItem.call(void 0, );
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call â€” at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  _util.expect.call(void 0, _types3.TokenType._new);
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (_base.isFlowEnabled) {
    _flow.flowStartParseNewArguments.call(void 0, );
  }
  if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
    parseExprList(_types3.TokenType.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  _index3.eat.call(void 0, _types3.TokenType.questionDot);
}

 function parseTemplate() {
  // Finish `, read quasi
  _index3.nextTemplateToken.call(void 0, );
  // Finish quasi, read ${
  _index3.nextTemplateToken.call(void 0, );
  while (!_index3.match.call(void 0, _types3.TokenType.backQuote) && !_base.state.error) {
    _util.expect.call(void 0, _types3.TokenType.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    _index3.nextTemplateToken.call(void 0, );
    // Finish quasi, read either ${ or `
    _index3.nextTemplateToken.call(void 0, );
  }
  _index3.next.call(void 0, );
} exports.parseTemplate = parseTemplate;

// Parse an object literal or binding pattern.
 function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = _base.getNextContextId.call(void 0, );
  let first = true;

  _index3.next.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;

  while (!_index3.eat.call(void 0, _types3.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
        break;
      }
    }

    let isGenerator = false;
    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      const previousIndex = _base.state.tokens.length;
      _lval.parseSpread.call(void 0, );
      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (_base.state.tokens.length === previousIndex + 2) {
          _lval.markPriorBindingIdentifier.call(void 0, isBlockScope);
        }
        if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
          break;
        }
      }
      continue;
    }

    if (!isPattern) {
      isGenerator = _index3.eat.call(void 0, _types3.TokenType.star);
    }

    if (!isPattern && _util.isContextual.call(void 0, _keywords.ContextualKeyword._async)) {
      if (isGenerator) _util.unexpected.call(void 0, );

      parseIdentifier();
      if (
        _index3.match.call(void 0, _types3.TokenType.colon) ||
        _index3.match.call(void 0, _types3.TokenType.parenL) ||
        _index3.match.call(void 0, _types3.TokenType.braceR) ||
        _index3.match.call(void 0, _types3.TokenType.eq) ||
        _index3.match.call(void 0, _types3.TokenType.comma)
      ) {
        // This is a key called "async" rather than an async function.
      } else {
        if (_index3.match.call(void 0, _types3.TokenType.star)) {
          _index3.next.call(void 0, );
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isPattern, isBlockScope, contextId);
  }

  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
} exports.parseObj = parseObj;

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return (
    !isPattern &&
    (_index3.match.call(void 0, _types3.TokenType.string) || // get "string"() {}
      _index3.match.call(void 0, _types3.TokenType.num) || // get 1() {}
      _index3.match.call(void 0, _types3.TokenType.bracketL) || // get ["string"]() {}
      _index3.match.call(void 0, _types3.TokenType.name) || // get foo() {}
      !!(_base.state.type & _types3.TokenType.IS_KEYWORD)) // get debugger() {}
  );
}

// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = _base.state.start;
  if (_index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (isPattern) _util.unexpected.call(void 0, );
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }
  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if (_index3.eat.call(void 0, _types3.TokenType.colon)) {
    if (isPattern) {
      _lval.parseMaybeDefault.call(void 0, isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.
  let identifierRole;
  if (isPattern) {
    if (_base.state.scopeDepth === 0) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = _index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = _index3.IdentifierRole.ObjectShorthand;
  }
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;

  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
  // parsing as if there's a default value.
  _lval.parseMaybeDefault.call(void 0, isBlockScope, true);
}

function parseObjPropValue(
  isPattern,
  isBlockScope,
  objectContextId,
) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseObjPropValue.call(void 0, );
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseObjPropValue.call(void 0, );
  }
  const wasMethod = parseObjectMethod(isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}

 function parsePropertyName(objectContextId) {
  if (_base.isFlowEnabled) {
    _flow.flowParseVariance.call(void 0, );
  }
  if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  } else {
    if (_index3.match.call(void 0, _types3.TokenType.num) || _index3.match.call(void 0, _types3.TokenType.string) || _index3.match.call(void 0, _types3.TokenType.bigint) || _index3.match.call(void 0, _types3.TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }

    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  }
} exports.parsePropertyName = parsePropertyName;

// Parse object or class method.
 function parseMethod(functionStart, isConstructor) {
  const funcContextId = _base.getNextContextId.call(void 0, );

  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  const allowModifiers = isConstructor; // For TypeScript parameter properties
  _statement.parseFunctionParams.call(void 0, allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
} exports.parseMethod = parseMethod;

// Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.
 function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
} exports.parseArrowExpression = parseArrowExpression;

 function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseFunctionBodyAndFinish.call(void 0, functionStart, funcContextId);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseFunctionBodyAndFinish.call(void 0, funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
} exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;

 function parseFunctionBody(allowExpression, funcContextId = 0) {
  const isExpression = allowExpression && !_index3.match.call(void 0, _types3.TokenType.braceL);

  if (isExpression) {
    parseMaybeAssign();
  } else {
    _statement.parseBlock.call(void 0, true /* isFunctionScope */, funcContextId);
  }
} exports.parseFunctionBody = parseFunctionBody;

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

function parseExprList(close, allowEmpty = false) {
  let first = true;
  while (!_index3.eat.call(void 0, close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, close)) break;
    }
    parseExprListItem(allowEmpty);
  }
}

function parseExprListItem(allowEmpty) {
  if (allowEmpty && _index3.match.call(void 0, _types3.TokenType.comma)) {
    // Empty item; nothing more to parse for this item.
  } else if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
    _lval.parseSpread.call(void 0, );
    parseParenItem();
  } else if (_index3.match.call(void 0, _types3.TokenType.question)) {
    // Partial function application proposal.
    _index3.next.call(void 0, );
  } else {
    parseMaybeAssign(false, true);
  }
}

// Parse the next token as an identifier.
 function parseIdentifier() {
  _index3.next.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
} exports.parseIdentifier = parseIdentifier;

// Parses await expression inside async function.
function parseAwait() {
  parseMaybeUnary();
}

// Parses yield expression inside generator.
function parseYield() {
  _index3.next.call(void 0, );
  if (!_index3.match.call(void 0, _types3.TokenType.semi) && !_util.canInsertSemicolon.call(void 0, )) {
    _index3.eat.call(void 0, _types3.TokenType.star);
    parseMaybeAssign();
  }
}

// https://github.com/tc39/proposal-js-module-blocks
function parseModuleExpression() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
  _util.expect.call(void 0, _types3.TokenType.braceL);
  // For now, just call parseBlockBody to parse the block. In the future when we
  // implement full support, we'll want to emit scopes and possibly other
  // information.
  _statement.parseBlockBody.call(void 0, _types3.TokenType.braceR);
}
