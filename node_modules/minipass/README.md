# minipass

A _very_ minimal implementation of a [PassThrough
stream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)

[It's very
fast](https://docs.google.com/spreadsheets/d/1K_HR5oh3r80b8WVMWCPPjfuWXUgfkmhlX7FGI6JJ8tY/edit?usp=sharing)
for objects, strings, and buffers.

Supports `pipe()`ing (including multi-`pipe()` and backpressure
transmission), buffering data until either a `data` event handler
or `pipe()` is added (so you don't lose the first chunk), and
most other cases where PassThrough is a good idea.

There is a `read()` method, but it's much more efficient to
consume data from this stream via `'data'` events or by calling
`pipe()` into some other stream. Calling `read()` requires the
buffer to be flattened in some cases, which requires copying
memory.

If you set `objectMode: true` in the options, then whatever is
written will be emitted. Otherwise, it'll do a minimal amount of
Buffer copying to ensure proper Streams semantics when `read(n)`
is called.

`objectMode` can only be set at instantiation. Attempting to
write something other than a String or Buffer without having set
`objectMode` in the options will throw an error.

This is not a `through` or `through2` stream. It doesn't
transform the data, it just passes it right through. If you want
to transform the data, extend the class, and override the
`write()` method. Once you're done transforming the data however
you want, call `super.write()` with the transform output.

For some examples of streams that extend Minipass in various
ways, check out:

- [minizlib](http://npm.im/minizlib)
- [fs-minipass](http://npm.im/fs-minipass)
- [tar](http://npm.im/tar)
- [minipass-collect](http://npm.im/minipass-collect)
- [minipass-flush](http://npm.im/minipass-flush)
- [minipass-pipeline](http://npm.im/minipass-pipeline)
- [tap](http://npm.im/tap)
- [tap-parser](http://npm.im/tap-parser)
- [treport](http://npm.im/treport)
- [minipass-fetch](http://npm.im/minipass-fetch)
- [pacote](http://npm.im/pacote)
- [make-fetch-happen](http://npm.im/make-fetch-happen)
- [cacache](http://npm.im/cacache)
- [ssri](http://npm.im/ssri)
- [npm-registry-fetch](http://npm.im/npm-registry-fetch)
- [minipass-json-stream](http://npm.im/minipass-json-stream)
- [minipass-sized](http://npm.im/minipass-sized)

## Usage in TypeScript

The `Minipass` class takes three type template definitions:

- `RType` the type being read, which defaults to `Buffer`. If
  `RType` is `string`, then the constructor _must_ get an options
  object specifying either an `encoding` or `objectMode: true`.
  If it's anything other than `string` or `Buffer`, then it
  _must_ get an options object specifying `objectMode: true`.
- `WType` the type being written. If `RType` is `Buffer` or
  `string`, then this defaults to `ContiguousData` (Buffer,
  string, ArrayBuffer, or ArrayBufferView). Otherwise, it
  defaults to `RType`.
- `Events` type mapping event names to the arguments emitted
  with that event, which extends `Minipass.Events`.

To declare types for custom events in subclasses, extend the
third parameter with your own event signatures. For example:

```js
import { Minipass } from 'minipass'

// a NDJSON stream that emits 'jsonError' when it can't stringify
export interface Events extends Minipass.Events {
  jsonError: [e: Error]
}

export class NDJSONStream extends Minipass<string, any, Events> {
  constructor() {
    super({ objectMode: true })
  }

  // data is type `any` because that's WType
  write(data, encoding, cb) {
    try {
      const json = JSON.stringify(data)
      return super.write(json + '\n', encoding, cb)
    } catch (er) {
      if (!er instanceof Error) {
        er = Object.assign(new Error('json stringify failed'), {
          cause: er,
        })
      }
      // trying to emit with something OTHER than an error will
      // fail, because we declared the event arguments type.
      this.emit('jsonError', er)
    }
  }
}

const s = new NDJSONStream()
s.on('jsonError', e => {
  // here, TS knows that e is an Error
})
```

Emitting/handling events that aren't declared in this way is
fine, but the arguments will be typed as `unknown`.

## Differences from Node.js Streams

There are several things that make Minipass streams different
from (and in some ways superior to) Node.js core streams.

Please read these caveats if you are familiar with node-core
streams and intend to use Minipass streams in your programs.

You can avoid most of these differences entirely (for a very
small performance penalty) by setting `{async: true}` in the
constructor options.

### Timing

Minipass streams are designed to support synchronous use-cases.
Thus, data is emitted as soon as it is available, always. It is
buffered until read, but no longer. Another way to look at it is
that Minipass streams are exactly as synchronous as the logic
that writes into them.

This can be surprising if your code relies on
`PassThrough.write()` always providing data on the next tick
rather than the current one, or being able to call `resume()` and
not have the entire buffer disappear immediately.

However, without this synchronicity guarantee, there would be no
way for Minipass to achieve the speeds it does, or support the
synchronous use cases that it does. Simply put, waiting takes
time.

This non-deferring approach makes Minipass streams much easier to
reason about, especially in the context of Promises and other
flow-control mechanisms.

Example:

```js
// hybrid module, either works
import { Minipass } from 'minipass'
// or:
const { Minipass } = require('minipass')

const stream = new Minipass()
stream.on('data', () => console.log('data event'))
console.log('before write')
stream.write('hello')
console.log('after write')
// output:
// before write
// data event
// after write
```

### Exception: Async Opt-In

If you wish to have a Minipass stream with behavior that more
closely mimics Node.js core streams, you can set the stream in
async mode either by setting `async: true` in the constructor
options, or by setting `stream.async = true` later on.

```js
// hybrid module, either works
import { Minipass } from 'minipass'
// or:
const { Minipass } = require('minipass')

const asyncStream = new Minipass({ async: true })
asyncStream.on('data', () => console.log('data event'))
console.log('before write')
asyncStream.write('hello')
console.log('after write')
// output:
// before write
// after write
// data event <-- this is deferred until the next tick
```

Switching _out_ of async mode is unsafe, as it could cause data
corruption, and so is not enabled. Example:

```js
import { Minipass } from 'minipass'
const stream = new Minipass({ encoding: 'utf8' })
stream.on('data', chunk => console.log(chunk))
stream.async = true
console.log('before writes')
stream.write('hello')
setStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!
stream.write('world')
console.log('after writes')
// hypothetical output would be:
// before writes
// world
// after writes
// hello
// NOT GOOD!
```

To avoid this problem, once set into async mode, any attempt to
make the stream sync again will be ignored.

```js
const { Minipass } = require('minipass')
const stream = new Minipass({ encoding: 'utf8' })
stream.on('data', chunk => console.log(chunk))
stream.async = true
console.log('before writes')
stream.write('hello')
stream.async = false // <-- no-op, stream already async
stream.write('world')
console.log('after writes')
// actual output:
// before writes
// after writes
// hello
// world
```

### No High/Low Water Marks

Node.js core streams will optimistically fill up a buffer,
returning `true` on all writes until the limit is hit, even if
the data has nowhere to go. Then, they will not attempt to draw
more data in until the buffer size dips below a minimum value.

Minipass streams are much simpler. The `write()` method will
return `true` if the data has somewhere to go (which is to say,
given the timing guarantees, that the data is already there by
the time `write()` returns).

If the data has nowhere to go, then `write()` returns false, and
the data sits in a buffer, to be drained out immediately as soon
as anyone consumes it.

Since nothø"“   (¼                       ÿÿÿÿfø    nø   yø   ‡ø"“   l¼                       ÿÿÿÿKú    "“    ¼                            ÿÿÿÿ¹ú    Áú    Îú    Öú    ãú    ëú    øú     û    û    û    "û    *û"“   $½                        ÿÿÿÿðQ"“   P½                       ÿÿÿÿìø    ôø   ÿø"“   ½                           ÿÿÿÿåû    ðû   øû   ü   ü   ü   $ü   /ü   :ü   Eü   Jü   Oü"“   ¾                       ÿÿÿÿMû    Xû   cû   nû   yû   „û   û    "“"   x¾                            ÿÿÿÿðQ    ðQ    ðQ   ðQ    ðQÿÿÿÿ|ü   ðQ   ðQ   ðQ   ðQ   ðQ   „ü   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   ðQ   Œü"“   ¬¿                       ÿÿÿÿXý"“   Ø¿   è¿               ÿÿÿÿ    ÿÿÿÿ                  ü¿	   ØðèÿÿÿŒx"“   0À                       ÿÿÿÿú    ú   ú"“   lÀ   |À               ÿÿÿÿ    ÿÿÿÿ                  À	   Øðèÿÿÿy"“   ÄÀ                       ÿÿÿÿtù    ù"“   øÀ                        ÿÿÿÿGù"“   $Á                        ÿÿÿÿ²ù"“   PÁ                        ÿÿÿÿ´ø    ¼ø"“                               "“   ¨Á                       ÿÿÿÿsú"“   ÔÁ   ôÁ               ÿÿÿÿ        ¦ÿ   ®ÿÿÿÿÿ                 Â   Øð¸ÿÿÿ9¢"“   <Â   TÂ               ÿÿÿÿ        =ÿÿÿÿÿ                 hÂ   ØðèÿÿÿÔœ"“   œÂ   ´Â               ÿÿÿÿ        `ÿÿÿÿÿ                 ÈÂ   Øðèÿÿÿq"“   üÂ   Ã               ÿÿÿÿ        ÷þÿÿÿÿ                 (Ã   Øðèÿÿÿ›"“   \Ã   „Ã               ÿÿÿÿ÷ÿ           ÿÿ                        ˜Ã   Øðàÿÿÿþ£"“   ÌÃ   ôÃ               ÿÿÿÿ€            ˆ                         Ä   Øðàÿÿÿ2§"“   <Ä   TÄ               ÿÿÿÿ        ƒÿÿÿÿÿ                 hÄ   Øðèÿÿÿož"“   œÄ   ´Ä               ÿÿÿÿ        * ÿÿÿÿ                 ÈÄ   Øðèÿÿÿ¸¤"“   üÄ   $Å                ÿÿÿÿó            û                        8Å   ØðØÿÿÿ'ª"“   lÅ   „Å               ÿÿÿÿ        Iÿÿÿÿ                 ˜Å   Øðèÿÿÿ¬"“   ÌÅ   äÅ               ÿÿÿÿ        &ÿÿÿÿ                 øÅ   Øðèÿÿÿ«"“   ,Æ   DÆ               ÿÿÿÿ        Ôÿÿÿÿÿ                 XÆ   Øðèÿÿÿè¢"“   ŒÆ   ´Æ                ÿÿÿÿM            U    ]                     ÈÆ   ØðØÿÿÿ¦"“   üÆ   Ç               ÿÿÿÿ        þ   þÿÿÿÿ                 0Ç   ØðÌÿÿÿt”"“   dÇ   ŒÇ               ÿÿÿÿ        ”þ   œþ   ¤þÿÿÿÿ                  Ç   Øð¨ÿÿÿ	™"“   ÔÇ   ôÇ               ÿÿÿÿ        \þ   dþÿÿÿÿ                 È   ØðÈÿÿÿÂ–"“   <È   TÈ               ÿÿÿÿ        ÿÿÿÿÿ                 hÈ   Øðèÿÿÿó›"“   œÈ   ÄÈ               ÿÿÿÿ³            »    Ã                     ØÈ   ØðÄÿÿÿ¼¨"“   É   $É               ÿÿÿÿ        Ôþÿÿÿÿ                 8É   Øðèÿÿÿš"“   lÉ   „É               ÿÿÿÿ        9þÿÿÿÿ                 ˜É   Øðäÿÿÿ{•"“   ÌÉ   Ê               ÿÿÿÿ        ¨ý    µý    Âý    Ïý    Üýÿÿÿÿ                 Ê	   Øð    Ëc"“   LÊ                       ÿÿÿÿ…ý"“   xÊ                       ÿÿÿÿl    w"“   ¬Ê   ÔÊ                ÿÿÿÿ           "   *ÿÿÿÿ                 èÊ   ØðÀÿÿÿ-¾"“   Ë   4Ë                ÿÿÿÿ        ¯ÿÿÿÿ                 HË   Øðäÿÿÿ¤Ä"“   |Ë   ¬Ë               ÿÿÿÿ        Ò   Ý   è   óÿÿÿÿ                 ÀË   Øð0þÿÿ„Æ"“   ôË   Ì               ÿÿÿÿß           ç   ÷                    0Ì   ØðäÿÿÿŠº"“   dÌ                       ÿÿÿÿª    ²"“   ˜Ì   ÐÌ               ÿÿÿÿ        P   [   f   q   |ÿÿÿÿ                 äÌ   Øð¤üÿÿ`Ã"“   Í                        ÿÿÿÿ&"“   DÍ   lÍ               ÿÿÿÿI           Q   Y                    €Í@           ÆÈ"“   ´Í                        ÿÿÿÿFÿÿÿÿQ"“   èÍ                        ÿÿÿÿ¼    Ç   Ò   Ý"“   ,Î                        ÿÿÿÿ„    "“   `Î                           ÿÿÿÿ†    Ž   ™   ¤   ¯   º   Å   Ð   Û   æ	   ô
   "“   äÎ                       ÿÿÿÿ^    i"“   Ï   (Ï               ÿÿÿÿ    ÿÿÿÿ                  <Ï	   Øðìÿÿÿ“Ú"“   pÏ                       ÿÿÿÿ;"“   œÏ                       ÿÿÿÿœ"“   ÈÏ                        ÿÿÿÿ    ðQÿÿÿÿ"“   Ð                       ÿÿÿÿÚ"“   0Ð                       ÿÿÿÿ"“   \Ð   lÐ               ÿÿÿÿ    ÿÿÿÿ                  €Ð@           Óâ"“   ´Ð                       ÿÿÿÿ"“   àÐ                       ÿÿÿÿU"“   Ñ                       ÿÿÿÿ""“   8Ñ                       ÿÿÿÿï"“   dÑ                       ÿÿÿÿ}    ˆ"“   ˜Ñ                       ÿÿÿÿ»ÿÿÿÿÆ"“   ÌÑ                       ÿÿÿÿZ"“   øÑ                       ÿÿÿÿ¢    ­   ¸   Æ"“   <Ò   \Ò               ÿÿÿÿ        ù   ÿÿÿÿ                 pÒ   ôð<ÿÿÿx""“   ¤Ò   ´Ò               ÿÿÿÿ    ÿÿÿÿ                  ÈÒ	   Øðìÿÿÿy	   8ñèÿÿÿÞy@           %z"“   Ó   ,Ó               ÿÿÿÿ    ÿÿÿÿ                  @Ó	   8ñ    ê'"“   tÓ                       ÿÿÿÿm"“    Ó   °Ó               ÿÿÿÿ    ÿÿÿÿ                  ÄÓ@           v+"“   øÓ                       ÿÿÿÿ“	ÿÿÿÿ›	"“   ,Ô   <Ô               ÿÿÿÿ    ÿÿÿÿ                  PÔ@           ö6"“   „Ô                       ÿÿÿÿÎ"“   °Ô   ÀÔ               ÿÿÿÿ    ÿÿÿÿ                  ÔÔ@           ;6"“   Õ   Õ               ÿÿÿÿ    ÿÿÿÿ                  ,Õ@           É4"“   `Õ   pÕ               ÿÿÿÿ    ÿÿÿÿ                  „Õ@           t3"“   ¸Õ   ÈÕ               ÿÿÿÿ    ÿÿÿÿ                  ÜÕ@           €5"“   Ö                       ÿÿÿÿ«"“   <Ö   LÖ               ÿÿÿÿ    ÿÿÿÿ                  `Ö@           µ."“   ”Ö                       ÿÿÿÿ    #   .   9"“   ØÖ                       ÿÿÿÿ¾	    Æ	"“   ×                       ÿÿÿÿ´"“   8×                       ÿÿÿÿ    %"“   l×                       ÿÿÿÿú"“   ˜×                       ÿÿÿÿ     (   0"“   Ô×                       ÿÿÿÿ×"“    Ø                       ÿÿÿÿÝ    è   ð"“   <Ø                       ÿÿÿÿs"“   hØ                       ÿÿÿÿê
    ò
"“   œØ                       ÿÿÿÿS"“   ÈØ                       ÿÿÿÿ¡"“   ôØ                       ÿÿÿÿ~"“    Ù                       ÿÿÿÿ    ""“   TÙ                       ÿÿÿÿH    P"“   ˆÙ                       ÿÿÿÿï    ÷"“   ¼Ù                       ÿÿÿÿÄ    Ì"“   ðÙ   (Ú               ÿÿÿÿ_    g   r   }   ‹                          <Ú   Øð    Ø="“   pÚ                       ÿÿÿÿ£
    «
   ¶
   Á
"“   ´Ú                       ÿÿÿÿ     ¨   °    "“   øÚ                           ÿÿÿÿì	    ÷	   
   
   
    
   +
   9
   A
   Q
	   Y

   a
   i
   v
"“   ŒÛ                       ÿÿÿÿE"“   ¸Û                       ÿÿÿÿðQ"“   äÛ                       ÿÿÿÿž    ©"“   Ümode.
- `end([chunk, [encoding]], [callback])` - Signal that you have
  no more data to write. This will queue an `end` event to be
  fired when all the data has been consumed.
- `pause()` - No more data for a while, please. This also
  prevents `end` from being emitted for empty streams until the
  stream is resumed.
- `resume()` - Resume the stream. If there's data in the buffer,
  it is all discarded. Any buffered events are immediately
  emitted.
- `pipe(dest)` - Send all output to the stream provided. When
  data is emitted, it is immediately written to any and all pipe
  destinations. (Or written on next tick in `async` mode.)
- `unpipe(dest)` - Stop piping to the destination stream. This is
  immediate, meaning that any asynchronously queued data will
  _not_ make it to the destination when running in `async` mode.
  - `options.end` - Boolean, end the destination stream when the
    source stream ends. Default `true`.
  - `options.proxyErrors` - Boolean, proxy `error` events from
    the source stream to the destination stream. Note that errors
    are _not_ proxied after the pipeline terminates, either due
    to the source emitting `'end'` or manually unpiping with
    `src.unpipe(dest)`. Default `false`.
- `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are
  EventEmitters. Some events are given special treatment,
  however. (See below under "events".)
- `promise()` - Returns a Promise that resolves when the stream
  emits `end`, or rejects if the stream emits `error`.
- `collect()` - Return a Promise that resolves on `end` with an
  array containing each chunk of data that was emitted, or
  rejects if the stream emits `error`. Note that this consumes
  the stream data.
- `concat()` - Same as `collect()`, but concatenates the data
  into a single Buffer object. Will reject the returned promise
  if the stream is in objectMode, or if it goes into objectMode
  by the end of the data.
- `read(n)` - Consume `n` bytes of data out of the buffer. If `n`
  is not provided, then consume all of it. If `n` bytes are not
  available, then it returns null. **Note** consuming streams in
  this way is less efficient, and can lead to unnecessary Buffer
  copying.
- `destroy([er])` - Destroy the stream. If an error is provided,
  then an `'error'` event is emitted. If the stream has a
  `close()` method, and has not emitted a `'close'` event yet,
  then `stream.close()` will be called. Any Promises returned by
  `.promise()`, `.collect()` or `.concat()` will be rejected.
  After being destroyed, writing to the stream will emit an
  error. No more data will be emitted if the stream is destroyed,
  even if it was previously buffered.

### Properties

- `bufferLength` Read-only. Total number of bytes buffered, or in
  the case of objectMode, the total number of objects.
- `encoding` Read-only. The encoding that has been set.
- `flowing` Read-only. Boolean indicating whether a chunk written
  to the stream will be immediately emitted.
- `emittedEnd` Read-only. Boolean indicating whether the end-ish
  events (ie, `end`, `prefinish`, `finish`) have been emitted.
  Note that listening on any end-ish event will immediateyl
  re-emit it if it has already been emitted.
- `writable` Whether the stream is writable. Default `true`. Set
  to `false` when `end()`
- `readable` Whether the stream is readable. Default `true`.
- `pipes` An array of Pipe objects referencing streams that this
  stream is piping into.
- `destroyed` A getter that indicates whether the stream was
  destroyed.
- `paused` True if the stream has been explicitly paused,
  otherwise false.
- `objectMode` Indicates whether the stream is in `objectMode`.
- `aborted` Readonly property set when the `AbortSignal`
  dispatches an `abort` event.

### Events

- `data` Emitted when there's data to read. Argument is the data
  to read. This is never emitted while not flowing. If a listener
  is attached, that will resume the stream.
- `end` Emitted when there's no more data to read. This will be
  emitted immediately for empty streams when `end()` is called.
  If a listener is attached, and `end` was already emitted, then
  it will be emitted again. All listeners are removed when `end`
  is emitted.
- `prefinish` An end-ish event that follows the same logic as
  `end` and is emitted in the same conditions where `end` is
  emitted. Emitted after `'end'`.
- `finish` An end-ish event that follows the same logic as `end`
  and is emitted in the same conditions where `end` is emitted.
  Emitted after `'prefinish'`.
- `close` An indication that an underlying resource has been
  released. Minipass does not emit this event, but will defer it
  until after `end` has been emitted, since it throws off some
  stream libraries otherwise.
- `drain` Emitted when the internal buffer empties, and it is
  again suitable to `write()` into the stream.
- `readable` Emitted when data is buffered and ready to be read
  by a consumer.
- `resume` Emitted when stream changes state from buffering to
  flowing mode. (Ie, when `resume` is called, `pipe` is called,
  or a `data` event listener is added.)

### Static Methods

- `Minipass.isStream(stream)` Returns `true` if the argument is a
  stream, and false otherwise. To be considered a stream, the
  object must be either an instance of Minipass, or an
  EventEmitter that has either a `pipe()` method, or both
  `write()` and `end()` methods. (Pretty much any stream in
  node-land will return `true` for this.)

## EXAMPLES

Here are some examples of things you can do with Minipass
streams.

### simple "are you done yet" promise

```js
mp.promise().then(
  () => {
    // stream is finished
  },
  er => {
    // stream emitted an error
  }
)
```

### collecting

```js
mp.collect().then(all => {
  // all is an array of all the data emitted
  // encoding is supported in this case, so
  // so the result will be a collection of strings if
  // an encoding is specified, or buffers/objects if not.
  //
  // In an async function, you may do
  // const data = await stream.collect()
})
```

### collecting into a single blob

This is a bit slower because it concatenates the data into one
chunk for you, but if you're going to do it yourself anyway, it's
convenient this way:

```js
mp.concat().then(onebigchunk => {
  // onebigchunk is a string if the stream
  // had an encoding set, or a buffer otherwise.
})
```

### iteration

You can iterate over streams synchronously or asynchronously in
platforms that support it.

Synchronous iteration will end when the currently available data
is consumed, even if the `end` event has not been reached. In
string and buffer mode, the data is concatenated, so unless
multiple writes are occurring in the same tick as the `read()`,
sync iteration loops will generally only have a single iteration.

To consume chunks in this way exactly as they have been written,
with no flattening, create the stream with the `{ objectMode:
true }` option.

```js
const mp = new Minipass({ objectMode: true })
mp.write('a')
mp.write('b')
for (let letter of mp) {
  console.log(letter) // a, b
}
mp.write('c')
mp.write('d')
for (let letter of mp) {
  console.log(letter) // c, d
}
mp.write('e')
mp.end()
for (let letter of mp) {
  console.log(letter) // e
}
for (let letter of mp) {
  console.log(letter) // nothing
}
```

Asynchronous iteration will continue until the end event is reached,
consuming all of the data.

```js
const mp = new Minipass({ encoding: 'utf8' })

// some source of some data
let i = 5
const inter = setInterval(() => {
  if (i-- > 0) mp.write(Buffer.from('foo\n', 'utf8'))
  else {
    mp.end()
    clearInterval(inter)
  }
}, 100)

// consume the data with asynchronous iteration
async function consume() {
  for await (let chunk of mp) {
    console.log(chunk)
  }
  return 'ok'
}

consume().then(res => console.log(res))
// logs `foo\n` 5 times, and then `ok`
```

### subclass that `console.log()`s everything written into it

```js
class Logger extends Minipass {
  write(chunk, encoding, callback) {
    console.log('WRITE', chunk, encoding)
    return super.write(chunk, encoding, callback)
  }
  end(chunk, encoding, callback) {
    console.log('END', chunk, encoding)
    return super.end(chunk, encoding, callback)
  }
}

someSource.pipe(new Logger()).pipe(someDest)
```

### same thing, but using an inline anonymous class

```js
// js classes are fun
someSource
  .pipe(
    new (class extends Minipass {
      emit(ev, ...data) {
        // let's also log events, because debugging some weird thing
        console.log('EMIT', ev)
        return super.emit(ev, ...data)
      }
      write(chunk, encoding, callback) {
        console.log('WRITE', chunk, encoding)
        return super.write(chunk, encoding, callback)
      }
      end(chunk, encoding, callback) {
        console.log('END', chunk, encoding)
        return super.end(chunk, encoding, callback)
      }
    })()
  )
  .pipe(someDest)
```

### subclass that defers 'end' for some reason

```js
class SlowEnd extends Minipass {
  emit(ev, ...args) {
    if (ev === 'end') {
      console.log('going to end, hold on a sec')
      setTimeout(() => {
        console.log('ok, ready to end now')
        super.emit('end', ...args)
      }, 100)
      return true
    } else {
      return super.emit(ev, ...args)
    }
  }
}
```

### transform that creates newline-delimited JSON

```js
class NDJSONEncode extends Minipass {
  write(obj, cb) {
    try {
      // JSON.stringify can throw, emit an error on that
      return super.write(JSON.stringify(obj) + '\n', 'utf8', cb)
    } catch (er) {
      this.emit('error', er)
    }
  }
  end(obj, cb) {
    if (typeof obj === 'function') {
      cb = obj
      obj = undefined
    }
    if (obj !== undefined) {
      this.write(obj)
    }
    return super.end(cb)
  }
}
```

### transform that parses newline-delimited JSON

```js
class NDJSONDecode extends Minipass {
  constructor(options) {
    // always be in object mode, as far as Minipass is concerned
    super({ objectMode: true })
    this._jsonBuffer = ''
  }
  write(chunk, encoding, cb) {
    if (
      typeof chunk === 'string' &&
      typeof encoding === 'string' &&
      encoding !== 'utf8'
    ) {
      chunk = Buffer.from(chunk, encoding).toString()
    } else if (Buffer.isBuffer(chunk)) {
      chunk = chunk.toString()
    }
    if (typeof encoding === 'function') {
      cb = encoding
    }
    const jsonData = (this._jsonBuffer + chunk).split('\n')
    this._jsonBuffer = jsonData.pop()
    for (let i = 0; i < jsonData.length; i++) {
      try {
        // JSON.parse can throw, emit an error on that
        super.write(JSON.parse(jsonData[i]))
      } catch (er) {
        this.emit('error', er)
        continue
      }
    }
    if (cb) cb()
  }
}
```
