"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(require("brace-expansion"));
const assert_valid_pattern_js_1 = require("./assert-valid-pattern.js");
const ast_js_1 = require("./ast.js");
const escape_js_1 = require("./escape.js");
const unescape_js_1 = require("./unescape.js");
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSetl l o c a t i o n P a s s  AÿÿS   Šo D a t a   ;   K• N a m e    P r o x i m i t y D o m a i n I n d e x  AÿÿM   Šo D a t a   5   K• N a m e    P r o x i m i t y D o m a i n I d  AÿÿK   Šo D a t a   3   K• N a m e    T o t a l D o m a i n P a g e s  AÿÿG   Šo D a t a   /   K• N a m e    P a g e s R e q u e s t e d  Aÿÿ=   Šo D a t a   %   K• N a m e   	 B a l S t a t u s 	 AÿÿG   Šo D a t a   /   K• N a m e    P a g e s A l l o c a t e d 
                  ø>                 ?        @      L?                `?                ?                ´?                ä?                @                4@                X@                p@  (   T o t a l S y s t e m P a g e s     ,   T o t a l P a g e s R e q u e s t e d      P o l i c y     0   P r o x i m i t y D o m a i n C o u n t     $   A l l o c a t i o n P a s s     0   P r o x i m i t y D o m a i n I n d e x     (   P r o x i m i t y D o m a i n I d   (   T o t a l D o m a i n P a g e s     $   P a g e s R e q u e s t e d        B a l S t a t u s   $   P a g e s A l l o c a t e d     PRVA`        ¨@  M i c r o s o f t - W i n d o w s - H y p e r - V - H y p e r v i s o r     OPCO0             0A     w i n : I n f o     LEVLŒ           PTA       PlA       PˆA     w i n : E r r o r      w i n : W a r n i n g   (   w i n : I n f o r m a t i o n a l   TASKÜ  
      ÿÿÿÿ                ÔB     ÿÿÿÿ                üB     ÿÿÿÿ                C     ÿÿÿÿ                <C     ÿÿÿÿ                lC     ÿÿÿÿ                ˜C     ÿÿÿÿ                ÈC     ÿÿÿÿ                ôC  	   ÿÿÿÿ                D  
   ÿÿÿÿ                HD  (   R e g i s t e r I n t e r f a c e      H v l d r I o c t l     $   R e m o t e H y p e r c a l l   0   H v l d r C r e a t e P a r t i t i o n     ,   R e g i s t e r P a r t i t i o n I d   0   H v l d r D e l e t e P a r t i t i o n     ,   H v l d r D e p o s i t M e m o r y     (   H v l d r M a p G p a P a g e s     ,   H v l d r U n m a p G p a S p a c e     D   H v l d r N u m a D i s t r i b u t e d A l l o c a t i o n     KEYWÜ             ÿÿÿÿØD          ÿÿÿÿE       @  ÿÿÿÿ(E       €  ÿÿÿÿDE  0   m s : R e s e r v e d K e y w o r d 4 4         m s : T e l e m e t r y        m s : M e a s u r e s   $   m s : C r i t i c a l D a t a   EVNTd  R                 @ €           HA         ØT  ˆ             @ €   à      HA         ÜT  ˆ             @ €           0A         àT  ˆ             @ €           <A         äT  ˆ   
          @  
  °8      HA         èT  ¨             @    °8      HA         ìT  ¨                ›  °t'      HA              ¨               › °L)      HA              ¨             @ €           <A         ğT  ˆ             @ €   °      0A         ôT  ˆ             @ €          0A         øT  ˆ             @ €           0A         üT  ˆ             @ €           0A          U  ˆ             @ €           0A         U  ˆ              @ €            0A         U  ˆ   "          @ €"         0A         U  ˆ   $          @ €$   0      0A         U  ˆ   %          @ €%   0      0A         U  ˆ   &          @ €&   L      0A         U  ˆ   '            @'  °H!      HA              ˜   (          @ €(          0A         U  ˆ   )          @ €)           0A          U  ˆ   *          @ €*           0A         $U  ˆ   ,          @ €,           0A         (U  ˆ   .          @ €.   ¼      0A         ,U  ˆ   0          @ €0         0A         0U  ˆ   6          @ €6           0A         4U  ˆ   7          @ €7           0A         8U  ˆ   8          @ €8           0A         <U  ˆ   ;          @ €;           0A         @U  ˆ   <          @ €<           0A         DU  ˆ   =          @ €=           0A         HU  ˆ   >          @ €>           0A         LU  ˆ   ?          @ €?   ¬      0A         PU  ˆ   @          @ €@           0A         TU  ˆ   P          @ € i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('.    äŒ  ¤  )    0  Ğ     Ø  z     €  p  è  x  c  P  l  p  h  x          "  ˜Œ  (  ƒ  ¤Œ  Œ  Å  °Œ  Ì  ú  °Œ     ¡  ¼Œ  ¨  (  ĞŒ  0  4  $’  @  Ò  ¤Œ  à  È  4  Ğ  v  P  |  v  d  |    t  ˆ  ÿ  œ     $  ¬  ”$  ê%  Ø  ğ%  )  ô   )  Ü)    ğ)  Ï*    à*  j+  ,  p+  ;.  8  D.  Û/  d  ä/  T0  ˆ  \0  °1     ¸1  3     3  C4  ´  L4  Ç5  È  Ğ5  .6  ˜Œ  46  ¼7  ü  Ä7  9    ¤9  ¨<  4  °<  €=  ´  =  ²=  ¤Œ  À=  Ú=  °Œ  à=  ğ@  €   A  "C  ¤  (C  ŞD  ¼  äD  »E  ˆ  ÄE  ©F  Ü  °F  ÒG  ü  ØG  ÂH    ĞH  ôH  °Œ   I   I  °Œ  (I  uI  ,  |I  CJ  <  LJ  |K  X  „K  L  ˆ   L  ÌL  ˆ  ÔL  ¿M  x  ÈM  O  x  O  ¤T  ”  ¬T  ×T  $’  àT  öT  $’  üT  PU   ‘  `U  U  °Œ  ¤U  úW  ,‘   X  !X  °Œ  (X  ‰\  H‘  \  œ]  x‘  ¤]  ô^  °‘  _  ._  è‘  @_  G_  $’  M_  Y_  $’  `_  d_  $’  x_  –_  °Œ  œ_  ü_  °Œ  `  Š`  ô‘   `  ga  ’  €a  …a  ğ‘  Àa  jd  ’  €d  ie   ’  oe  ‘e  Ì  Ğ  ‰Ğ  Ø  Ğ  'Ñ  ä  0Ñ  µÑ  ,  ¼Ñ  FÒ  ‘  LÒ  Ò   ‘  ˜Ò  ÀÓ  ˆ  ÈÓ  `Ô  d‘  hÔ  
Õ  ˆ  Õ  A×  ‘  P×  ²×   ‘  À×  4Ø  °‘  <Ø  ÙÙ  À‘  àÙ  õÚ  Ü‘  à  _ä  ğŒ  pä  œä  ,  ¤ä  Òä  $’                                                                                                                                                                                                                                                                                                                                                                                                              îÈ              ğË      ĞË      ºË      ¢Ë      ˆË      bË      FË      *Ë      Ë      äÊ      ÒÊ      ¸Ê      šÊ      zÊ      dÊ      TÊ      DÊ      Ê      Ê      äÉ      ÊÉ      ¬É      É      2Ê              É      ,É      DÉ      jÉ              TÌ      BÌ      lÌ      0Ì      Ì      ~Ì              8È      È      È      øÅ      æÇ      ÈÇ      ¬Ç      ”Ç      €Ç      hÇ      PÇ      VÈ      0Ç      Ç      üÆ      æÆ      ÈÆ      ®Æ      ”Æ      €Æ      hÆ      JÆ      *Æ      Æ      Æ      pÈ      ŒÈ      ¦È      ÀÈ      ÌÈ      >Ç      öÍ      œÌ      °Ì      ¾Ì      ÎÌ      ŞÌ      òÌ      Í      &Í      LÍ      lÍ      ŒÍ      šÍ      ¾Í      ÚÍ      
Î              `_ À   €a À   xÄ          àÈ  8Á  @Ã          
É   À  Ä          †É  ØÀ  PÃ          Ì  À  @Ä          ’Ì   Á                      îÈ              ğË      ĞË      ºË      ¢Ë      ˆË      bË      FË      *Ë      Ë      äÊ      ÒÊ      ¸Ê      šÊ      zÊ      dÊ      TÊ      DÊ      Ê      Ê      äÉ      ÊÉ      ¬É      É      2Ê              É      ,É      DÉ      jÉ              TÌ      BÌ      lÌ      0Ì      Ì      ~Ì              8È      È      È      øÅ      æÇ      ÈÇ      ¬Ç      ”Ç      €Ç      hÇ      PÇ      VÈ      0Ç      Ç      üÆ      æÆ      ÈÆ      ®Æ      ”Æ      €Æ      hÆ      JÆ      *Æ      Æ      Æ      pÈ      ŒÈ      ¦È      ÀÈ      ÌÈ      >Ç      öÍ      œÌ      °Ì      ¾Ì      ÎÌ      ŞÌ      òÌ      Í      &Í      LÍ      lÍ      ŒÍ      šÍ      ¾Í      ÚÍ      
Î               EtwWriteTransfer  y EtwUnregister t EtwRegister ™MmMapLockedPagesSpecifyCache  /KeAcquireSpinLockRaiseToDpc ‹KeInitializeSpinLock  æKeReleaseSpinLock "ExReleaseSpinLockShared ˜ ExAcquireSpinLockShared  ExReleaseSpinLockExclusive  áRtlCreateHashTable  – ExAcquireSpinLockExclusive  øRtlDeleteHashTable  ?KeBugCheck  ø ExQueueWorkItem £ ExAllocatePoolWithTag ÊKeQueryTimeIncrement  Ê ExFreePoolWithTag d__C_specific_handler  	RtlQueryRegistryValuesEx  	RtlEnumerateEntryHashTable  RtlEndEnumerationHashTable  ¢RtlIpv4AddressToStringW 	RtlRemoveEntryHashTable xRtlInitEnumerationHashTable RtlInsertEntryHashTable [RtlGetNextEntryHashTable  ªRtlIpv6AddressToStringW ÑRtlLookupEntryHashTable ·	SeExports ÅRtlCompareMemory  ntoskrnl.exe  T KeQueryPerformanceCounter HAL.dll <NetioNrtIsProxyInRecord :NetioNrtIsIpInRecord  7NetioNrtFindAndReferenceRecordById  3NetioNrtDereferenceRecord NETIO.SYS ’ NdisFRegisterFilterDriver ‡ NdisFDeregisterFilterDriver  NdisFreeCloneOidRequest  NdisAllocateCloneOidRequest NdisInitializeEvent  NdisFOidRequestComplete  NdisFOidRequest  NdisWaitEvent ŞNdisSetEvent  ™ NdisFSetAttributes   NdisAllocateNetBufferListPool  NdisFreeCloneNetBufferList  NdisWriteEventLogEntry  £ NdisFreeMemory   NdisAllocateMemoryWithTagPriority ‹ NdisFGetOptionalSwitchHandlers  © NdisFreeNetBufferListPool – NdisFReturnNetBufferLists Œ NdisFIndicateReceiveNetBufferLists  — NdisFSendNetBufferLists § NdisFreeNetBufferList ‘ NdisFPauseComplete  Å NdisGetPoolFromNetBufferList  ˜ NdisFSendNetBufferListsComplete NDIS.SYS  9 RpcBindingCreateW  NdrClientCall3  7 RpcBindingBind   I_RpcExceptionFilter  : RpcBindingFree  ? RpcBindingUnbind  msrpc.sys  KeIsExecutingDpc  +ExSetTimer  ¶ ExDeleteTimer @KeBugCheckEx  w EtwSetInformation ¥ ExAllocateTimer ;ExTryAcquirePushLockExclusiveEx #ExReleaseSpinLockSharedFromDpcLevel Œ ExAcquirePushLockExclusiveEx  ExReleasePushLockExclusiveEx  KeSetEvent  ™ ExAcquireSpinLockSharedAtDpcLevel ExReleasePushLockSharedEx  ExAcquirePushLockSharedEx ƒKeInitializeEvent 0KeWaitForSingleObject                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì@L‹”$€   H‹ÙM…Òt\L‹\$p‹Â…Òt#ƒøu"A¶È¸   ÿÁM‰JE„ÀM‰ZEÁA‰ëAƒ" I‹B(H…Àt!I‹J0H‰L$0H‹L$xH‰L$(H‹ËL‰\$ ÿ>òÿÿHƒÄ@[ÃÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì@H‹ĞÿÿH3ÄH‰D$0H‹ALI H‹Ù@ğL‰A0L‹ÁH‰Q(HAÿÿÿHL$ óD$ HÿñÿÿD  ‹ø…ÀuL‹CPH‹K E·HÿVñÿÿD  ‹ÇH‹L$0H3ÌèúÿÿH‹\$XH‹t$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì 3ÿH‹Ù@8¹t  t@ˆ¹t  è¼  ëè  9»   t‹“p  H‹‹h  è‡ƒÿÿH‹‹  ¸   fğ±y8fƒøuH‹‹  E3ÀHƒÁ 3ÒHÿäğÿÿD  H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌ@SHƒìPHƒ¹h   H‹ÙtpH‹  º   f‡P8fƒúu%H‹‰  E3ÉHƒd$  HƒÁ E3À3ÒHÿ£ğÿÿD  H‹‹h  LL$0A°WÀ3ÀAŠĞD$0H‰D$@HÿğÿÿD  Hƒ£h   HƒÄP[ÃÌÌÌÌÌÌÌH…Ét=SHƒì H‹Ùè^ÿÿÿH‹‹  H…Ét3ÒHÿïÿÿD  3ÒH‹ËHÿôîÿÿD  HƒÄ [ÃÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì @Šò¿x  ‹×A¸TrAG¹   HÿÀîÿÿD  3íH‹ØH…ÀtD‹Ç3ÒH‹Èèœ‘ÿÿH…Û„¯   º@   H‰«  ¹   A¸TrAGHÿ}îÿÿD  H‹øH…Àt3ÒH‹ÈDB@èZ‘ÿÿH‰»  H…ÿtjHO E3À3ÒHÿîîÿÿD  H‹ƒ  HÛıÿÿH‰HH‰XH‰(H‹ƒ  f‰h8@„öt7H‹“  HâÿÿA¸   HÿÕîÿÿD  H‰ƒh  H…ÀuH‹Ëè¨şÿÿH‹İH‹l$8H‹ÃH‹\$0H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌÌÌH…Ò„   H‰\$H‰t$WHƒì0H‹úH‹ñ¶G-º   Â;ÂvJH‹GHIÿÂÆDı ¶G-ƒÀ;Ğ|æ¶W,E3ÉH‹GE3ÀH‰D$(H‹Î‰T$ H‹×HÿíÿÿD  H‹_H‹Ïè¹ƒÿÿH‹ûH…Ûu—H‹\$@H‹t$HHƒÄ0_ÃÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì 3ÿH‹Ù9¹   tk‹©  ‹õ‹ÆHƒ<Ã t‹ÖH‹Ëèì‡ÿÿøÿÆƒæ;õtƒÿrİ‰³  …ÿt69»8  w
Hƒ»(   u‰»8  9»4  s‰»4  Hÿƒ(  ‹ÇHƒ   H‹\$0H‹l$8H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌH‰\$H‰|$UHl$ Hì`  H‹’ËÿÿH3ÄH‰EP‹   3ÿH‹Ù…À„×  D‹8  H‹‰(  D;ÀwH…Éu	‰ƒ8  D‹À‹“4  ;Ğs‰ƒ4  ‹ĞL‹ÈLQL‹   L‰‹   L‰“(  „q  ƒ=ÜÊÿÿ†@  I»     @  L…ÕÊÿÿ„)  H‹ĞÊÿÿI#ÃH;ÆÊÿÿ…  H‹ƒX  HÇEH   HÇE8   HÇE(   H‹H‹ƒD  HÇE   HÇE   Ağ‰D$0H`Êÿÿ‹ƒ@  ‰D$4‹ƒ<  ‰D$8‹ƒ0  H‰D$PHD$0H‰E@HD$4H‰E0HD$8H‰E HD$<H‰EHD$@H‰E HD$HH‰EğHD$PH‰EàHD$XH‰EĞHEˆH‰EÀHE D‰D$<E3À‰T$@H'²ÿÿL‰L$HE3ÉH‰D$(ÇD$    óEˆL‰T$XHÇEø   HÇEè   HÇEØ   HÇEÈ   è9ÿÿWÀ3Àƒ   H‰E€ƒ0  òE€òƒ@  ‹×H‹Ëèx…ÿÿÿÇƒÿ rïH‹MPH3Ìèå‡ÿÿLœ$`  I‹[I‹{ I‹ã]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌƒúu[SHƒì Iƒù uK3ÒHçÍÿÿHÿøêÿÿD  „Àt2H‹ØÍÿÿëH‹Ëè†ıÿÿH‹›`  H…Ûuì3ÒH±ÍÿÿHÿÚêÿÿD  HƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì@H‹œ$€   EŠØ‹úH‹ƒH  H…Àt)L‹“P  L‹D$pL‰T$0L‹T$xL‰T$(L‰D$ EŠÃÿ´êÿÿƒÿu
H‹Ëè÷üÿÿëƒÿuH‹Ëè@üÿÿH‹\$PHƒÄ@_ÃÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒìPH‹nÈÿÿH3ÄH‰D$@²è7úÿÿH‹ØH…ÀuE3ÀHÕÇÿÿ3Òèøÿÿ‹øé8  Hƒ H   H5¸ÇÿÿHƒ P   HT$0ƒd$  HL$ H‰°X  A¸   Æ€u   H‹Çÿÿ@ğH‹ÃHÁèH‰D$(óD$0èÏ{ÿÿA¸   HT$(HL$ èº{ÿÿHL$ èä{ÿÿ‹L$ ¸…Ùo÷áL‹ÃÁêiÂÀ'	 H¦şÿÿ+ÈÁÀ'	 ‰‹p  H‹Îè`÷ÿÿ‹ø…Ày
H‹Ëèùÿÿëy3ÒHÌÿÿHÿ(éÿÿD  H‹üËÿÿH…ÀuE3ÀHåıÿÿHÇÿÿè÷ÿÿH‹ÚËÿÿHÓËÿÿëH9°X  tHˆ`  H‹H…ÀuèH‰3ÒH¥ËÿÿHÿÎèÿÿD  3ÿ‹ÇH‹L$@H3ÌèH…ÿÿH‹\$`H‹t$hHƒÄP_ÃÌÌÌÌÌÌÌÌ@WHƒì HÓıÿÿH9|Æÿÿt'H‹kÆÿÿHƒ%cÆÿÿ ƒ%<Æÿÿ HÿåçÿÿD  éÑ   3ÿH*Ëÿÿ3ÒHÿIèÿÿD  H‹ËÿÿHËÿÿëLıÅÿÿH`  L9X  tH‹H‹ĞH…ÉuŞë:H‹ H‹ùH‰èšúÿÿHƒ=ÚÊÿÿ u"H‹ÆÿÿHƒ%Æÿÿ ƒ%êÅÿÿ Hÿ[çÿÿD  3ÒH¥ÊÿÿHÿÎçÿÿD  H…ÿtH‹ÏèøöÿÿH‹ÅÿÿHƒ%•Åÿÿ ƒ%nÅÿÿ HÿçÿÿD  H‹Ïè^÷ÿÿHƒÄ _ÃÌ                                                                                                                                                                                                                                                                           ÌÌÌÌÌÌÌÌ@USVWATAVAWH¬$pÿÿÿHì  L‹ù3ÒHL$@A¸à   èI„ÿÿE3äL‰=ÏÀÿÿEŠôL‰%ÍÀÿÿèì÷ÿÿƒ=ñ¿ÿÿv&H°“ÿÿH‰…Ğ   H`¤ÿÿH…Ğ   H‰D$ è%0ÿÿè7ÿÿ3ÒH£ÂÿÿA¸  èèƒÿÿH™“ÿÿ¾  H‹Â‹şfD9 t
HƒÀHƒïuğH‹ÇH÷ØÛ÷Óã  ÀH…ÿtH‹ÆH+ÇëI‹ÄL H…ÿuM‹ÄëHDÂÿÿfD‰:ÂÿÿèÅ€ÿÿH…ÿuJƒ=A¿ÿÿ†â  HD“ÿÿHĞ£ÿÿH‰…à   H…Ğ   H‰D$(H…à   H‰D$ ‰Ğ   èë/ÿÿé¥  3ÒHÍ¿ÿÿA¸  è"ƒÿÿH“ÿÿH‹şH‹ÂfD9 t
HƒÀHƒïuğH‹ÇH÷ØÛ÷Óã  ÀH…ÿtH+÷ëI‹ôL6H…ÿuM‹ÄëHu¿ÿÿfD‰k¿ÿÿè€ÿÿH…ÿu ƒ=‚¾ÿÿ†#  Hı’ÿÿH£ÿÿé<ÿÿÿ3ÒD‰¥à   HM D‰¥è   DBpè„‚ÿÿH¡ÿÿÇE(   H‰E0LE H…à   ÇE@   H‰E8H¡ÿÿH…è   ÇEP   E3ÉH‰EH¹   €L‰d$ HÿßÿÿD  D9¥à   •Àƒ=á½ÿÿˆÓÂÿÿv4ˆ…Ğ   H-¢ÿÿHm’ÿÿH‰D$0H…Ğ   H‰D$(HD$0H‰D$ è5/ÿÿîÿÿH‹_¾ÿÿH8CÿÿéÿÿH‰ELN¾ÿÿHHÿÿÇD$@‹à H‰E˜LD$@HGÿÿHÇD$D H‰E I‹ÏH FÿÿH‰E¨HÕ6ÿÿH‰EØHº9ÿÿH‰EàH¿ZÿÿH‰E°HÔ]ÿÿH‰E¸H‰ZÿÿH‰EĞHNZÿÿóD$PH‰EÈHí5ÿÿ^ÿÿI‰GhóL$`óD$pHÿOİÿÿD  ‹Ø…ÀtAƒ=Å¼ÿÿvj‰…Ğ   HY¡ÿÿHo‘ÿÿH‰…à   H…Ğ   H‰D$(H…à   H‰D$ éƒıÿÿƒ=„¼ÿÿA¶vlH`‘ÿÿH‰…Ğ   Hğ ÿÿH…Ğ   H‰D$ èµ,ÿÿ…ÛtBö½ÿÿtHM‘ÿÿD‹ËH‰D$ èğ3ÿÿè·3ÿÿA€şuH‹ö¼ÿÿHÿÜÿÿD  è­õÿÿëöÄ¼ÿÿtLK‘ÿÿè^4ÿÿ‹ÃHÄ  A_A^A\_^[]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì H‹ÚH‹ùè   H‹ÓH‹ÏèxûÿÿH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌH‹¼ÿÿH…ÀtH¹2¢ß-™+  H;ÁtH÷ĞH‰ÿ»ÿÿÃÌ¹   Í)                                                                                                                                                                                                                                                                                                                 @  à  Ğ  ğ%   )  ğ)  à*  =  À=  à=   A  °F  ĞH   I  `U  @_  `_  Ğ  0Ñ  P×  À×  pä                                                                                                                                                                                                                                                                                                                                                                                                                                                    ” €8  €x €P  €   h  €   €  €   ˜  €                  °  €                  È  €               9  à  €                  ø  €                   €               	  (                 	  8                 	  H                 	  X                 	  h  ¸ ø           à Ú          À
 ô           € \            Ü           W E V T _ T E M P L A T E  M U I     Ì4   V S _ V E R S I O N _ I N F O     ½ïş     
  aJ  
  aJ?                       *   S t r i n g F i l e I n f o      0 0 0 0 0 4 B 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n    3  F i l e D e s c r i p t i o n     M i c r o s o f t   D e f e n d e r   A p p l i c a t i o n   G u a r d   F i l t e r   D r i v e r     h $  F i l e V e r s i o n     1 0 . 0 . 1 9 0 4 1 . 1   ( W i n B u i l d . 1 6 0 1 0 1 . 0 8 0 0 )   :   I n t e r n a l N a m e   h v s i f l t r . s y s     € .  L e g a l C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   B   O r i g i n a l F i l e n a m e   h v s i f l t r . s y s     j %  P r o d u c t N a m e     M i c r o s o f t ®   W i n d o w s ®   O p e r a t i n g   S y s t e m     >   P r o d u c t V e r s i o n   1 0 . 0 . 1 9 0 4 1 . 1     D    V a r F i l e I n f o     $    T r a n s l a t i o n       °                             4     P  PÌ     P  Pà          X  W D A G   F i l t e r   f a i l e d   N T S T A T U S :   % 1   M s g : lowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = require("./ast.js");
Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
var escape_js_2 = require("./escape.js");
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
var unescape_js_2 = require("./unescape.js");
Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map